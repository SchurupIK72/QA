# Введение в QA

В Appfox **QA Engineer** --- это специалист, который обеспечивает
качество продукта на всех этапах разработки. Это не просто поиск ошибок,
а комплексный процесс, интегрированный от описания проекта до
тестирования, релиза и даже пост-релизного обслуживания.

#### **Терминология QA**

  -----------------------------------------------------------------------------
  Термин             Определение
  ------------------ ----------------------------------------------------------
  **QA Engineer**    Специалист, обеспечивающий качество продукта. QA Engineer
                     участвует во всех процессах, связанных с качеством, на
                     каждом этапе разработки продукта: от описания проекта до
                     тестирования, релиза и даже пост-релизного обслуживания.

  **QA Lead**        Руководитель отдела тестирования.

  **Общее            Относится к взаимодействию с другими членами команды,
  взаимодействие**   такими как Геймдизайнер / Проектный менеджер /
                     Разработчики.
  -----------------------------------------------------------------------------

#### **Ответственность и обязанности QA Engineer**

**Основная ответственность QA Engineer** --- обеспечение качества
продукции в соответствии с заявленными требованиями и спецификациями.
Это включает моделирование нестандартных ситуаций, регулировку поведения
конечного пользователя, внесение предложений по улучшению продукта и
поддержание тестовой документации.

**Типичные обязанности QA Engineer:**

- Ручное тестирование продукта.

- Тестирование документации.

- Моделирование ситуаций, которые могут возникнуть при использовании
  программного обеспечения.

- Указание приоритета найденных ошибок и создание отчётов в специальных
  местах для хранения баг-репортов.

- Отслеживание процесса исправления ошибок, актуализация статусов
  ошибок.

- Участие в планерках.

- Создание и поддержание тестовой документации в актуальном состоянии.

- Постоянное профессиональное развитие.

- Обмен опытом с командой.

- Генерирование новых идей и внесение предложений по улучшению рабочего
  процесса.

- Предоставление отчётов по результатам тестирования.

#### **Типичный день QA Engineer**

Твой типичный рабочий день как QA Engineer включает в себя:

- Обязательное участие в **планерках**.

- Выполнение текущих задач в зависимости от их приоритета:

  - Тестирование продукта.

  - Написание документации, необходимой для тестирования.

  - Тестирование проектной документации.

  - Проверка исправленных ошибок (багфиксов).

  - Решение текущих ситуаций и вопросов.

# Терминология (словарь тестировщика)

#### **Общие термины:**

![image.png](./media/image5.png){width="3.3472222222222223in"
height="3.3472222222222223in"}

#### **Словарь по Git:**

# Немного теории

#### **Принципы тестирования:**

**Исчерпывающее тестирование невозможно\**
Насколько бы тщательным тестирование не было, нельзя учесть все
возможные сценарии и предвидеть все возможные ошибки.

**Тестирование демонстрирует наличие дефектов, а не их отсутствие\**
Тестирование может выявить тот момент, что ошибки присутствуют, но не
может доказать в полной мере, что дефектов нет.

**Заблуждение об отсутствии ошибок\**
Можно сколько угодно находить ошибки, и даже, казалось бы, не
обнаруживая их больше, нет гарантии того, что ошибки найдены все и
продукт полностью качественный и готовый.

**Раннее тестирование сохраняет время и деньги\**
Это принцип говорит о том, что чем раньше выявится та или иная
проблема - тем меньше средств и трудозатрат потребуется для её
устранения. Соответственно, если баг попадёт в «прод» или ещё хуже, если
его найдёт пользователь -- исправление такого дефекта обойдётся немалой
кровью для всей команды.

**Принцип скопления или кластеризация дефектов\**
Существует такое определение -- наибо́льшее количество дефектов обычно
содержится в небольшо́м количестве модулей. Простыми словами
кластеризация -- это группировка (на кластеры) множества объектов,
схожих между собой по каким-либо параметрам. Представим полки и витрины
в магазине -- товары подразделены на хлебобулочные, молочные, мясные,
напитки и др. Это и есть кластеризация.

**Тестирование зависит от контекста\**
Для разного софта будут применяться разные подходы к его тестированию. К
примеру, способ тестирования мобильного приложения будет отличаться от
того, которым тестируется коммерческий сайт.

**Парадокс пестицида\**
Если к какому-либо функционалу применять постоянно повторяющийся набор
тестов, то эффективность обнаружения ошибок при проведении данных
проверок в скором времени будет снижаться.

#### **Уровни тестирования программного обеспечения:**

#### 

![image.png](./media/image17.png){width="4.8125in" height="3.125in"}

- **Компонентное или Модульное тестирование (Component Testing or Unit
  Testing)** - Компонентное (модульное) тестирование проверяет
  функциональность и ищет дефекты в частях приложения, которые доступны
  и могут быть протестированы по-отдельности (модули программ, объекты,
  классы, функции и т.д.). Обычно компонентное (модульное) тестирование
  проводится вызывая код, который необходимо проверить и при поддержке
  сред разработки, таких как фреймворки (frameworks - каркасы) для
  модульного тестирования или инструменты для отладки. Все найденные
  дефекты, как правило исправляются в коде без формального их описания в
  системе менеджмента багов (Bug Tracking System). По существу эти
  уровни тестирования представляют одно и тоже, разница лишь в том, что
  в компонентном тестировании в качестве параметров функций используют
  реальные\
  объекты и драйверы, а в модульном тестировании - конкретные значения.
  Одна из отличительных черт Unit-тестов - покрывают только маленькую
  часть программного кода (одну функцию или метод).

- **Интеграционное тестирование (Integration Testing)** - Интеграционное
  тестирование предназначено для проверки связи между компонентами, а
  также взаимодействия с различными частями системы (операционной
  системой, оборудованием либо связи между различными системами).\
  *Уровни интеграционного тестирования:*

  - *Компонентный интеграционный уровень* *(Component Integration
    testing)* проверяется взаимодействие между компонентами системы
    после проведения компонентного тестирования.

  - *Системный интеграционный уровень (System Integration Testing)*
    проверяется взаимодействие между разными системами после проведения
    системного тестирования

- **Системное тестирование (System Testing)** - Основной задачей
  системного тестирования является проверка как функциональных, так и не
  функциональных требований в системе в целом. При этом выявляются
  дефекты, такие как неверное использование ресурсов системы,
  непредусмотренные комбинации данных пользовательского уровня,
  несовместимость с окружением, непредусмотренные сценарии
  использования, отсутствующая или неверная функциональность, неудобство
  использования и т.д. Для минимизации рисков, связанных с особенностями
  поведения системы в той или иной среде, во время тестирования
  рекомендуется использовать окружение максимально приближенное к тому,
  на которое будет установлен продукт после выдачи.\
  *Можно выделить два подхода к системному тестированию:*

  - *на базе требований (requirements based)* для каждого требования
    пишутся тестовые случаи (test cases), проверяющие выполнение данного
    требования.

  - *на базе случаев использования (use case based)* на основе
    представления о способах использования продукта создаются случаи
    использования системы (Use Cases). По конкретному случаю
    использования можно определить один или более сценариев. На проверку
    каждого сценария пишутся тест-кейсы (test cases), которые должны
    быть протестированы.

- **Приемочное тестирование (Acceptance Testing)** - Формальный процесс
  тестирования, который проверяет соответствие системы требованиям и
  проводится с целью определения удовлетворяет ли система приемочным
  критериям и для вынесения решения заказчиком или другим уполномоченным
  лицом принимается приложение или нет. Решение о проведении приемочного
  тестирования принимается, когда продукт достиг необходимого уровня
  качества, заказчик ознакомлен с Планом Приемочных Работ (Product
  Acceptance Plan) или иным документом, где описан набор действий,
  связанных с проведением приемочного тестирования, дата проведения,
  ответственные и т.д.

#### **Связанные с изменениями виды тестирования**

После проведения необходимых изменений, таких как исправление
бага/дефекта, программное обеспечение должно быть перетестировано для
подтверждения того факта, что проблема была действительно решена. Ниже
перечислены виды тестирования, которые необходимо проводить после
установки программного обеспечения, для подтверждения работоспособности
приложения или правильности осуществленного исправления дефекта:

- **Подтверждающее тестирование или Re-test**

Подтверждающее тестирование направлено на проверку исправления бага.
Суть его в том, что после исправление дефекта программное обеспечение
может быть протестировано с использованием тестовых сценариев, которые
завершились с ошибкой из-за найденного дефекта.

- **Регрессионное тестирование или Regression Testing**

Регрессионное тестирование - это вид тестирования направленный на
проверку изменений, сделанных в приложении или окружающей среде (починка
дефекта, слияние кода, миграция на другую операционную систему, базу
данных, веб сервер или сервер приложения), для подтверждения того факта,
что существующая ранее функциональность работает как и прежде

Как правило, для регрессионного тестирования используются тест кейсы,
написанные на ранних стадиях разработки и тестирования. Это дает
гарантию того, что изменения в новой версии приложения не повредили уже
существующую функциональность. Рекомендуется делать автоматизацию
регрессионных тестов, для ускорения последующего процесса тестирования и
обнаружения дефектов на ранних стадиях разработки программного
обеспечения.

- **Дымовое тестирование или Smoke Testing**

Понятие дымовое тестирование пошло из инженерной среды: \"При вводе в
эксплуатацию нового оборудования (\"железа\") считалось, что
тестирование прошло удачно, если из установки не пошел дым.\"\
В области же программного обеспечения, дымовое тестирование
рассматривается как короткий цикл тестов, выполняемый для подтверждения
того, что после сборки кода (нового или исправленного) устанавливаемое
приложение, стартует и выполняет основные функции.

- **Санитарное тестирование или проверка согласованности/исправности или
  Sanity Testing**

Санитарное тестирование - это узконаправленное тестирование достаточное
для доказательства того, что конкретная функция работает согласно
заявленным в спецификации требованиям. Является подмножеством
регрессионного тестирования. Используется для определения
работоспособности определенной части приложения после изменений
произведенных в ней или окружающей среде. Обычно выполняется вручную.

- **Тестирование сборки или Build Verification**

Направлено на определение соответствия выпущенной версии критериям
качества для начала тестирования. По своим целям является аналогом
дымового тестирования, направленного на приемку новой версии в
дальнейшее тестирование или эксплуатацию.

#### **Требования:**

- **Функциональные требования**

**Функциональные требования** - это функции («фичи»), реализуемые
командой при разработке программного продукта. Если более конкретно, то
функциональные требования --- это вычисления, выполняемые программным
решением, а также способы потребления, обработки и генерации данных,
которые описывают, что делает программное обеспечение.

*Нарпимер, под функциональными требованиями можно подразумевать
совокупность всех используемых команд меню, представленных кнопками с
условными значками этих команд.*

Определение функциональных требований --- обязательный этап процесса
разработки. Эти требования обычно исходят из юзкейсов (сценариев
использования), созданных будущими операторами разрабатываемого решения,
то есть пользователями. Команда разработчиков анализирует эти кейсы,
сопоставляя их с наличными функциями и определяя необходимые технологии
реализации.

Существует несколько категорий функциональных требований. Среди них
уместно выделить следующие:

1.  **Аутентификация**: относится к способам идентификации пользователя

2.  **Уровни авторизации**: относится к разнородным привилегиям и
    ограничениям, накладываемым на пользователей. Например, указывается,
    кто может выполнять CRUD-операции (изменение, чтение, обновление или
    удаление) в данном программном решении

3.  **Внешние интерфейсы**: касаются внешних интерфейсов решения,
    которые обеспечивают его связь с другими решениями, системами и
    пользователями

4.  **Обработка транзакций**: касаются способов анализа и работы с
    транзакциями, такими как ввод, изменение, удаление и отмена

5.  **Соответствие нормативным требованиям**: касается законов, правил и
    политики, которым должна следовать организация, в которой будет
    работать программное решение

Конечно, существуют и многие другие категории функциональных требований,
которые относятся к таким сферам как резервное копирование,
восстановление, аудит, архивирование данных и т. д. Однако они
применяются в системах лишь с определенными характеристиками. Кстати, не
существует абсолютно обязательной категории функциональных требований;
мы должны определять их в соответствии с особенностями программного
проекта.

- **Нефункциональные требования**

**Нефункциональные требования** - это атрибуты и свойства,
представляющие собой ожидания качества программного решения. Набор
нефункциональных требований сильно зависит от конкретных сценариев
использования.

**Определение нефункциональных требований не является обязательной
задачей.** Мы можем разрабатывать продукт, руководствуясь только набором
функциональных требований. Однако, при этом продукт будет работать по
модели best-effort, например не соответствуя ожиданиям по параметрам
производительности или презентабельности.

Какие ожидания мы имеем в виду? Существует множество косвенных
параметров, которые мы должны учитывать. Эти параметры относятся к
различным категориям нефункциональных требований. Итак, рассмотрим
наиболее распространенные категории и их параметры:

1.  **Удобство пользования**: определяет, насколько удобный продукт. Эта
    категория включает такие параметры, как воспринимаемая зрительная
    нагрузка, эффективность использования, и интуитивность.

2.  **Безопасность**: как программное решение защищает свои данные.
    Параметры этой категории включают в себя политику разрешений,
    защищенность и устойчивость к атакам.

3.  **Надежность**: касается того, как программное решение избегает
    сбоев и справляется с ними. Примером параметра является вероятность
    того, что случится сбой в компоненте до определенного времени
    непрерывной работы.

4.  **Производительность**: касается отзывчивости программного
    обеспечения при взаимодействии с ним. Наиболее распространенным
    примером параметра в этом случае является максимально допустимое
    время реакции на каждое действие пользователя.

5.  **Доступность**: касается времени, в течение которого программное
    решение доступно для использования. Параметрами например являются
    максимальное время работы и максимальное время восстановления после
    потенциальных сбоев.

6.  **Масштабируемость**: связана с увеличением или уменьшением
    возможностей программного обеспечения без ущерба для его
    производительности. К примеру, определение минимального и
    максимального количества поддерживаемых пользователей.

# Конфиденциальная информация. QA

Эта страница составлена на основе общего регламента
\"[**Конфиденциальная
информация**](https://wiki.appfox.ru/books/akademiya-vvedenie-v-appfox-1-uroven-GwE/page/bezopasnost-i-konfidencialnost-cto-vazno-znat-s-pervogo-dnya)\"
и содержит дополнительные рекомендации, предназначенные специально для
аудиторов ТЗ, чтобы обеспечить строгий контроль и соблюдение
конфиденциальности в Appfox.

#### **Соблюдение конфиденциальности в процессе тестирования**

Помимо общих правил, изложенных в основном регламенте, тестировщикам
необходимо придерживаться следующих рекомендаций для защиты
конфиденциальной информации:

- **Личные учётные данные:** Никогда не передавайте свои личные учётные
  данные для входа в рабочие сервисы.

- **Проверка тестовых данных:** Тщательно проверяйте тестовые данные и
  результаты на предмет наличия конфиденциальной информации.

- **Обезличивание данных:** Всегда используйте обезличенные или
  маскированные данные в тест-кейсах для защиты конфиденциальной
  информации (например, при работе с админ-панелью).

- **Удаление данных:** Удаляйте любые файлы с конфиденциальной
  информацией после завершения тестирования.

- **Ограничение доступа к файлам:** Не передавайте доступ к рабочим
  файлам и материалам своим друзьям или родственникам, даже если хотите
  поделиться результатами работы.

- **Безопасность авторизационных данных:**

  - Не используйте логины и пароли для авторизации, которые уже
    применяются на тестовом и продуктовом серверах (например, в
    админ-панели), или данные для соединения с сервером.

  - Не используйте данные аутентификации, токены авторизации и тому
    подобное в своих запросах к чат-ботам (например, Chat GPT).

- **Хранение доступов:** Не храните доступы к материалам рабочих
  проектов в открытом месте. Если вы храните их в Google Docs или Google
  Таблицах, обязательно ставьте защиту на лист.

- **Контроль доступа к тестовым средам:** Ограничивайте доступ к
  тестовым средам, особенно если они содержат реальные данные
  пользователей. Данные должны быть видны только лицам, причастным к
  проектам. Если данные занесены в какой-то документ (например, Google
  Таблицу), залейте их чёрным цветом, чтобы они не попадали на скриншоты
  и не были видны другим людям.

- **Прямое взаимодействие:** Не взаимодействуйте (созвоны и переписки)
  напрямую с людьми, которые не состоят в составе команды проекта или не
  находятся на сервере проекта в Discord, при обсуждении деталей
  проекта.

- **Автоматизация тестов:** Убедитесь, что автоматизированные тесты
  хранятся в защищённых репозиториях с контролем версий и прав доступа.

# Набор инструкций и правил для легкого старта и работы на проекте

Этот регламент разработан, чтобы обеспечить плавный старт и эффективную
работу QA-специалиста над проектом. Здесь ты найдёшь все необходимые
шаги и правила для успешного выполнения своих задач.

#### **Введение в проект**

Приступая к работе над новым проектом, обязательно изучи всю доступную
информацию. Это поможет быстро вникнуть в суть и эффективно выполнять
задачи.

**Необходимые для изучения материалы:**

- **Карточки с общей информацией по проекту.**

- **Discord-чаты** с актуальными новостями и обсуждениями по проекту.

- **Договор и приложенные материалы** (при необходимости, уточняется у
  ПМа).

- **Референсы похожих игр/приложений**, чтобы понять контекст и
  ожидания.

- **Рабочая таблица по проекту.**

- **ГДД (геймдизайн-документ)**, если проект игровой.

- **Тестовая документация** (существующая, если есть).

**После изучения материалов:**

- **Обсуди с Проектным менеджером (ПМом)** количество часов, которое
  необходимо уделять проекту в неделю. Далее работай строго по
  согласованному графику.

- **Уточни, в каком виде лучше предоставлять отчёты** ПМу о проделанной
  работе.

- **Отчитывайся по факту выполнения** поставленных задач.

#### **Работа над задачами на проекте**

Твоя работа на проекте делится на два основных типа: **регулярная
работа** и **задачи, поставленные ПМом**.

##### **Регулярная работа**

Это основные, обязательные для любого проекта пункты, которые необходимо
выполнять на периодической основе:

- **Проверка статуса новых материалов** --- периодичность уточняется
  (каждый день или по запросу ПМа).

- **Проверка карточек в столбце \"На проверке\"** --- ежедневно. Если
  нет актуального билда для проверки или есть иные детали, обязательно
  укажи это в комментарии и сообщи о проблеме ПМу.

- **Проведение регрессионного тестирования** в каждом новом билде.

- **Создание и поддержка тестовой документации** в актуальном состоянии.

- **Контроль за доской проекта**.

##### **Задачи, поставленные ПМом**

Эти задачи определяются Проектным менеджером и могут включать в себя
любые поручения, для выполнения которых у тебя достаточно компетенций
тестировщика. Они должны быть подробно изложены и зафиксированы в задаче
с описанием.

#### **Регулярная работа: Детали выполнения задач**

Чтобы эффективно выполнять регулярную работу, важно знать, как устроены
регламентированные процессы проекта:

- Задача: \"Проверка карточек в столбце \'На проверке\'\"\
  Для выполнения этой задачи тебе необходимо понимать следующие разделы:

  - **Задача:** [Критерии
    приёмки](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/kriterii-priemki-IZT),
    [Статусы](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/statusy-zadac-i-put-bag-reporta).

  - **Баг-репорт:**
    [Эталон](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/etalon-bag-reporta-BkB),
    [Статусы](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/statusy-zadac-i-put-bag-reporta),
    [Места
    хранения](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/mesta-xraneniya-bag-reportov).

  - **Билды:**
    [Билд-ноутсы](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/rabota-s-bildami)
    и коммуникации по билду, [Одобрение функциональной
    ветки](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/odobrenie-funkcionalnoi-vetki-pered-sliyaniem-v-osnovnuyu-vetku)
    перед сливанием в основную ветку.

- Задача: \"Написать тестовую документацию\"\
  Для выполнения этой задачи тебе нужно знать, как устроены следующие
  регламентированные процессы:

  - [Шаблоны тестовой
    документации](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/sablony-dlya-testovoi-dokumentacii-v9J).

  - [Описание
    тест-плана](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/opisanie-test-plana).

- Задача: \"[Контроль за доской
  проекта](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/kontrol-za-doskoi)\"\
  Для выполнения этой задачи тебе необходимо знать раздел:

  - Контроль за доской проекта.

- Задача: \"Тестирование вёрстки по таблице с дизайн-согласованием\"\
  Для выполнения этой задачи тебе нужно знать раздел:

  - [Рабочая таблица
    проекта](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/rabocaya-tablica-proekta).

# Коммуникации с командой и заказчиками

Эффективная координация команды --- залог успешной и своевременной
работы над проектом. В Appfox для этого используются ежедневные
планерки.

#### **Ежедневные планерки**

Проектный менеджер (ПМ) назначает удобное время созвона и на ежедневной
основе проводит планерки с командой на сервере проекта в Discord. Если у
сотрудника нет работы по проекту в этот день, приходить на планерку без
важной необходимости не требуется.

Планерки носят **координационный характер**. В рамках планерки не
решаются задачи или проблемы, и команда не уходит в обсуждения. Это
позволяет избежать превращения 20-минутной планерки в диалог на 60 минут
и более, что может парализовать работу одновременно всех специалистов,
работающих над проектом.

В идеале на одного человека должно уходить **3-5 минут**, не больше.
Каждый выступающий должен ответить на три вопроса:

1.  **Что сделал из задач вчера?**

2.  **Какую задачу будешь делать сегодня?**

3.  **Нужна ли помощь от кого-то из команды или от ПМа, и если нужна, то
    в чём конкретно?**

ПМ начинает планерку и первым отвечает на эти три вопроса. Далее по
очереди на них отвечают все члены команды. Заканчивает планерку также
ПМ.

Если необходимо решить какой-либо вопрос, подавите искушение решить его
тут же в рамках этого диалога, если только ответ на него не требует 1-2
минуты. Всё, что занимает больше времени, организовывайте отдельным
диалогом.

#### **Коммуникации с заказчиком**

**Коммуникации напрямую с заказчиком запрещены!**

Общение допускается только на общем сервере проекта в Discord. Если
заказчику требуется созвон с сотрудником, это должно происходить в
связке **сотрудник + ПМ**.

Если заказчик пишет в личные сообщения, в обход общего сервера,
необходимо:

1.  Сообщить об этом ПМу проекта.

2.  Ответить на сообщение заказчика в общем чате проекта, перенося туда
    коммуникацию.

# Контроль за доской

Контроль за доской проекта в нашей CRM-системе --- это неотъемлемая
часть работы, которая помогает поддерживать качество и эффективность.
Задача тестировщика --- постоянно проверять, насколько качественно
ведётся CRM всеми участниками.

#### **Суть задачи**

Проверять соответствие поставленной задачи и результата её выполнения. В
каждой проверенной задаче внутри CRM **обязательно оставлять
комментарий** с указанием итога проверки и приложением вспомогательных
материалов (видеоролики, скриншоты экрана). Желательно выделять
проблемную область или указывать конкретное время ролика для лучшего
понимания исполнителями выявленной проблемы.

Чтобы работа считалась выполненной (прошедшей проверку), **обязательно
должны присутствовать пруфы** в формате GIF, фото или видео.

#### **Проверка карточек на доске**

При просмотре карточек тестировщик должен обращать внимание на их
**корректное заполнение**. При несоответствии сообщать ПМу.

В карточке должны присутствовать:

- Название карточки\*

- Описание задачи\*

- Указание исполнителя\*

- Указание типа задачи (правильная категория в CRM)\*

- Указание тегов (если по договорённости с ПМом в окнах должны быть
  теги, проверяй их актуальность)

- Примерное время исполнения\*

- Точный срок исполнения

- [Критерии
  приёмки](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/kriterii-priemki-IZT)

**Все пункты с \"\*\" обязательны к заполнению.**

#### **Управление задачами в статусе \"На проверке\"**

Задачи в статусе \"На проверке\" **не должны скапливаться и подолгу
задерживаться** в этой колонке.

- Задача с момента её перехода в статус \"На проверке\" должна быть
  **закрыта в течение 5 дней**, но чем раньше тестировщик её закроет,
  тем лучше.

- Одновременно в статусе \"На проверке\" должно находиться **не более 5
  задач**.

Если задачу невозможно проверить и закрыть из-за того, что ещё не собран
новый билд для тестирования (и в нём нельзя проверить фиксы или
выполненные задачи), **необходимо оставить комментарий \"жду новый
билд\"** (указать причину, почему задача \"горит\" по срокам, и почему
мы не можем её проверить). Также сообщить ПМу, что задача просрочена.

Если для тестирования выполненной задачи тестировщику необходимы
какие-либо данные, но у него их нет (например, логин и пароль от учётной
записи), **не спешить возвращать её в работу**. Обратиться напрямую к
исполнителю задачи для уточнения деталей.

# Рабочая таблица проекта

В Appfox для каждого проекта используется стандартный шаблон рабочей
таблицы, в которой тестировщикам необходимо заполнять определённые
колонки для контроля качества.

#### **Колонка: \"Вёрстка сходится с дизайном?\"**

![image.png](./media/image2.png){width="4.052083333333333in"
height="3.2916666666666665in"}Тестировщик заполняет эту колонку в
формате **\"Да\"** или **\"Нет\"**. Если в поле обнаружена ошибка,
вместо надписи \"Нет\" указывается **номер задачи со ссылкой на карточку
в CRM**.

При обнаружении проблемы необходимо:

- **Описать проблему комментарием в карточке.**

- **Прикрепить пруфы (доказательства)** с указанием проблемных областей
  и описанием.

- При необходимости можно оставить дополнительный комментарий в колонке
  \"Комментарий\".

![image.png](./media/image1.png){width="6.267716535433071in"
height="1.5in"}

#### **Проверка вёрстки**

Необходимо тщательно изучить проделанную работу по вёрстке игровых окон
и окон меню, а затем создать отчёт по итогу, согласно
[примеру](https://docs.google.com/spreadsheets/d/12caO1Q3oEuKLqaxWBgXE64CGT1spv1tR9IF92rhIcWA/edit?gid=1762326488#gid=1762326488).

**Что включает в себя проверка вёрстки:**

- **Кликабельность активных элементов экранов** игры --- убедитесь, что
  все интерактивные элементы реагируют на действия пользователя.

- **Соответствие размера и количества элементов** --- проверьте, что
  элементы соответствуют размерам и количеству, указанным в дизайне.

- **Добавление простых анимаций** --- если это возможно реализовать без
  написания кода, проверьте наличие и корректность простых анимаций.

После проверки обязательно **оставьте комментарий в карточках о
фактическом результате** проделанной работы --- соответствует ли вёрстка
дизайну или нет.

Эталон для вёрстки:

В качестве эталона для проверки вёрстки используется готовый дизайн,
согласованный с заказчиком. Несогласованный дизайн не может служить
эталоном.

**Особенности проверки:**

- Проверку необходимо осуществлять на **мобильном устройстве и
  эмуляторе**.

- Заранее узнайте у геймдизайнера (ГД), предусмотрена ли
  **вертикальная/горизонтальная или адаптивная вёрстка**. При наличии
  такой вёрстки обязательно протестируйте её на разных ориентациях
  экрана.

# Описание тест плана

#### **Тест план**

[Тест-план](https://docs.google.com/spreadsheets/d/12caO1Q3oEuKLqaxWBgXE64CGT1spv1tR9IF92rhIcWA/edit?gid=193830760#gid=193830760)
(Test plan) --- это фундаментальный документ, описывающий полный объём
работ по тестированию. Он охватывает всё: от определения объекта
тестирования и выбранной стратегии, до расписания, критериев начала и
завершения, необходимого оборудования, специальных знаний и оценки
рисков с планами их смягчения.

**Тест план должен отвечать на следующие вопросы:**

  --------------------------------------
  Что необходимо протестировать?
  --------------------------------------
  Как будет проводиться тестирование?

  Когда будет проводиться тестирование?

  Критерии начала тестирования.

  Критерии окончания тестирования.
  --------------------------------------

**Основные пункты тест плана:**

# Описание чек-листа и тест-кейса

В тестировании программного обеспечения \"чек-листы\" и \"тест-кейсы\"
являются основными инструментами для организации и документирования
проверок. Понимание различий между ними и их правильного применения
критически важно для обеспечения качества продукта.

#### **Чек-лист**

**Чек-лист** --- это упорядоченный список пунктов, которые необходимо
проверить, выполнить или учесть во время тестирования. Он служит для
упрощения и структурирования процесса тестирования, помогая
тестировщикам не забыть о важных аспектах функциональности и сделать
процесс проверки более систематичным и прозрачным. **Один пункт
чек-листа = одной проверке.**

##### **Цели чек-листа**

- **Структурирование тестирования:** Помогает организовать процесс
  тестирования, разбивая его на отдельные, чётко определённые шаги или
  пункты.

- **Обеспечение полноты покрытия тестами:** Гарантирует, что все важные
  аспекты и функции системы будут проверены, помогает избежать пропуска
  важных тестов.

- **Упрощение процесса тестирования:** Предоставляет готовый список
  пунктов для проверки, экономя время.

- **Повышение прозрачности:** Позволяет легко отслеживать процесс
  тестирования и фиксировать, какие проверки были выполнены, а какие ещё
  нет.

- **Улучшение качества:** Повышает общее качество тестирования за счёт
  систематического подхода и структурированной проверки всех аспектов
  системы.

##### **Задачи чек-листа**

- **Идентификация ключевых областей:** Определение основных
  функциональных областей и аспектов системы, которые необходимо
  проверить, а также включение критичных и часто используемых функций.

- **Разделение на шаги:** Разделение процесса тестирования на отдельные,
  чётко определённые шаги или пункты.

- **Учёт всех видов тестирования:** Включение в чек-лист проверок для
  всех типов тестирования: функционального, нефункционального (например,
  производительность, безопасность) и других.

- **Поддержка актуальности:** Регулярное обновление и дополнение
  чек-листа с учётом новых функций, изменений в системе и обнаруженных
  дефектов.

##### **Основные атрибуты чек-листа**

  ----------------------------------------------------------------------------
  Атрибут                 Описание
  ----------------------- ----------------------------------------------------
  **Идентификатор**       Уникальный номер или код для каждого пункта
                          чек-листа, помогающий в отслеживании.

  **Название пункта**     Краткое описание или заголовок пункта, который нужно
                          проверить.

  **Описание**            Подробное описание того, что нужно проверить или
                          выполнить в данном пункте.

  **Критерии приёмки**    Условия, при выполнении которых пункт считается
                          выполненным успешно.

  **Статус**              Текущий статус выполнения пункта:\
                          - **Failed**: пункт пройден с ошибкой.\
                          - **Passed**: пункт пройден успешно.\
                          - **Skipped**: пункт пропущен (не реализовано/серая
                          зона/нельзя проверить).

  **Комментарии/пруфы**   Поле для заметок, скриншотов, связанных с
                          выполнением пункта.
  ----------------------------------------------------------------------------

Для чек-листа \"ожидаемый результат\" не является обязательным
атрибутом, но для удобства использования его можно прописывать.

##### **Правила при составлении чек-листа**

- Соблюдайте одинаковую структуру.

- Учитывайте логическую последовательность проверок.

- Будьте логичны при написании проверок.

- Обеспечьте продукту полноту покрытия проверками.

- Не пишите явно избыточные проверки.

![image.png](./media/image4.png){width="6.267716535433071in"
height="2.5416666666666665in"}

#### **Тест-кейс**

**Тест-кейс (или тестовый сценарий)** --- это документ, описывающий
набор действий, условий и входных данных, разработанных для проверки
определённой функции или части программного обеспечения с целью
удостовериться в его правильной работе. Тест-кейс включает в себя
подробное описание шагов выполнения, ожидаемых и фактических
результатов.

##### **Цели тест-кейса**

- **Валидация функциональности:** Убедиться, что программное обеспечение
  выполняет свои функции в соответствии с требованиями.

- **Обеспечение качества:** Проверка и подтверждение качества, выявление
  и устранение дефектов на ранних стадиях разработки.

- **Документирование тестирования:** Создание подробной документации,
  которая позволяет отслеживать выполнение тестирования и его
  результаты.

- **Повышение повторяемости:** Обеспечение возможности повторного
  выполнения тестов для проверки стабильности после внесения изменений в
  код.

- **Обеспечение полноты покрытия:** Гарантия того, что все аспекты и
  функциональность системы протестированы и проверены.

##### **Задачи тест-кейса**

- **Определение входных данных и условий:** Указать начальные условия,
  при которых тест будет выполняться (например, настройки системы,
  предварительные данные).

- **Описание шагов тестирования:** Подробное описание последовательности
  действий, которые необходимо выполнить для проверки определённой
  функции.

- **Определение ожидаемых результатов:** Указание ожидаемых результатов
  выполнения каждого шага теста, что позволяет сравнить их с
  фактическими результатами.

- **Критерии приёмки:** Условия, при выполнении которых тест считается
  успешным (например, отсутствие ошибок, корректные входные данные).

- **Обеспечение трассируемости:** Связь тест-кейсов с требованиями,
  которые они проверяют, чтобы гарантировать, что все требования
  протестированы.

##### **Основные атрибуты тест-кейса**

  ----------------------------------------------------------------------------
  Атрибут                 Описание
  ----------------------- ----------------------------------------------------
  **Идентификатор**       Уникальный номер или код для каждого тест-кейса,
                          помогающий в его отслеживании и управлении.

  **Название тест-кейса** Краткое описание или заголовок, описывающий цель
                          тест-кейса.

  **Предусловия**         Начальные условия или настройки, которые должны быть
                          выполнены перед выполнением теста.

  **Шаги тестирования**   Последовательность действий, которые необходимо
                          выполнить.

  **Ожидаемые             Описание ожидаемых результатов для каждого шага или
  результаты**            всего теста в целом.

  **Фактические           Результаты, полученные в ходе выполнения теста,
  результаты**            которые сравниваются с ожидаемыми результатами.

  **Статус тестирования** Текущий статус тест-кейса:\
                          - **Failed**: тест не пройден (с ошибкой).\
                          - **Passed**: тест пройден успешно.\
                          - **Skipped**: тест пропущен (не реализовано/серая
                          зона/нельзя проверить).

  **Комментарии/пруфы**   Поле для заметок, скриншотов, связанных с
                          выполнением пункта.
  ----------------------------------------------------------------------------

##### **Виды тест-кейсов**

Тест-кейсы делятся на несколько групп в зависимости от входных данных,
действий и предполагаемого поведения системы:

- **Позитивные тест-кейсы:** Доказывают, что программное обеспечение
  отвечает всем требованиям. Проверяют, что при вводе корректных данных
  и правильных действиях пользователя система реагирует адекватно. Эти
  тест-кейсы необходимо проверять в первую очередь.

- **Негативные тест-кейсы:** Их результаты позволяют убедиться в
  способности программного обеспечения правильно реагировать на
  ошибочные вводные или некорректные действия. Это может быть, например,
  появление всплывающего окна с подсказкой об ошибке.

- **Деструктивные тест-кейсы:** Служат для проверки способности системы
  выдерживать большие нагрузки и внешние воздействия без утери данных
  пользователя. При их выполнении должно соблюдаться условие о запрете
  повреждения аппаратной части.

##### ![image.png](./media/image15.png){width="6.267716535433071in" height="1.4861111111111112in"}**Требования к тест-кейсам**

- **Чёткие формулировки:** Тест-кейс должен быть написан максимально
  понятно.

- **Самостоятельное выполнение:** Любой человек должен иметь возможность
  выполнить тест-кейс в отсутствие его автора на проекте.

- **Определённость результата:** Тест-кейс должен чётко определять
  ожидаемый результат проверки, чтобы тестировщик мог однозначно понять,
  успешно ли пройдено тестирование.

##### **Категории тест-кейсов в иностранной литературе**

В иностранной литературе часто делят тест-кейсы на две основные
категории:

- **Высокоуровневый тест-кейс (high-level test case или logical test
  case):** Тест-кейс без конкретных входных данных и ожидаемых
  результатов. Как правило, ограничивается общими идеями и операциями,
  схож по своей сути с подробно описанным пунктом чек-листа. Достаточно
  часто встречается в интеграционном и системном тестировании, а также
  на уровне smoke-тестов. Может служить отправной точкой для проведения
  исследовательского тестирования или для создания низкоуровневых
  тест-кейсов.

- **Низкоуровневый тест-кейс (low-level test case):** Тест-кейс с
  конкретными входными данными и ожидаемыми результатами. Представляет
  собой \"полностью готовый к выполнению\" тест-кейс и является наиболее
  классическим видом тест-кейсов. Начинающих тестировщиков чаще всего
  учат писать именно такие тесты, поскольку прописать все данные
  подробно намного проще, чем понять, какой информацией можно
  пренебречь, не снизив при этом ценность тест-кейса.

#### **Разница между тест-кейсом и чек-листом**

  -------------------------------------------------------------------------------------
  Аспект                   Тест-кейс                 Чек-лист
  ------------------------ ------------------------- ----------------------------------
  **Детализация**          Все расписано очень       Простой, без глубокой детализации.
                           детально: пошаговое       Просто памятка или перечень
                           описание, входные данные, пунктов.
                           ожидаемые результаты.     

  **Цель**                 Подтвердить, что          Убедиться, что все основные
                           конкретная функция        аспекты функциональности
                           работает правильно при    проверены; структурировать
                           определённых условиях.    процесс.

  **Выполнение**           Может выполнить даже      Другому человеку может быть сложно
                           человек, который ни разу  вникнуть в суть проверок без
                           не видел тестируемое      детальных шагов.
                           приложение.               

  **Создание/Поддержка**   Создание и поддержка      Проще в создании и поддержке.
                           требует времени, сил и    
                           является рутиной. Часто   
                           подразумевает только один 
                           конкретный тест.          

  **Применимость**         Идеален для критических,  Стал популярнее с приходом гибких
                           стабильных функций и для  моделей разработки (Agile), когда
                           обучения.                 писать детальные кейсы может не
                                                     быть времени и смысла (всё
                                                     меняется слишком быстро).

  **Отчётность**           Отчётность может быть     Довольно наглядный с точки зрения
                           очень подробной, но       отчётности.
                           требует больше усилий.    
  -------------------------------------------------------------------------------------

# Шаблоны тестовой документации

[Тестовая
документация](https://docs.google.com/spreadsheets/d/12caO1Q3oEuKLqaxWBgXE64CGT1spv1tR9IF92rhIcWA/edit#gid=526128879)
в Appfox ведётся в формате Google Таблиц и является ключевым элементом
для обеспечения качества продукта. Она позволяет систематизировать
процесс тестирования, контролировать его ход и обеспечивать прозрачность
на всех этапах разработки.

### Определения тестовой документации

- **Мастер-план** - это обширный документ, который охватывает все
  аспекты тестирования в рамках всего проекта. Он может включать в себя
  несколько отдельных тест-планов, каждый из которых относится к
  конкретным фазам или компонентам проекта.

[[Цели и задачи мастер-плана:\]{.underline}
- Обеспечить общее руководство для всех тестовых мероприятий в проекте.\
- Координировать работу между различными командами и этапами
тестирования.\
- Установить стандарты и процедуры для всех тестовых процессов в
проекте.\
- Обеспечить комплексное покрытие всх требований и целей
тестирования.]{.mark}

- **Тест-план** - это документ, описывающий весь объем работ по
  тестированию, начиная с описания объекта, стратегии, расписания,
  критериев начала и окончания тестирования, до необходимого в процессе
  работы оборудования, специальных знаний, а также оценки рисков с
  вариантами их разрешения.

[[Цели и задачи тест-плана:\]{.underline}
- Определить объекты тестирования.\
- Обозначить проблемы и риски.\
- Описать подходы и стратегии тестировани\
- Определить критерии приемки и завершения тестирования.\
- Определить подходы и стратегии тестирования.\
- Установить график выполнения тестовых мероприятий в соответствии с
задачами разработки]{.mark}

- **Смоук-тестирование** (или дымовое тестирование) - это вид
  тестирования, который проводится для быстрой проверки базовой
  работоспособности приложения после сборки.

[[Цели и задачи смоук-тестирования:\]{.underline}
- Убедиться, что основные функции приложения работают корректно, и что
дальнейшее более глубокое тестирование имеет смысл.\
- Определение критических тест-кейсов: выбор небольшого набора тестов,
которые охватывают основные и критические функции приложения.\
- Регулярное проведение: проведение после каждой новой сборки или
значительных изменений в коде.]{.mark}

- **Регрессионное тестирование** - это тип тестирования, направленный на
  проверку того, что изменения (новые функции, исправления багов,
  оптимизация) не нарушили существующую функциональность.

[[Цели и задачи регрессионного тестирования:\]{.underline}
- Обеспечение стабильности приложения: убедиться, что новые изменения не
привели к нарушению существующей функциональности, а также проверка, что
исправленные баги не появились снвоа (реинкарнация багов).\
- Сохранение качества продукта: убедиться, что добавление новых функций
не повредило работающие ранее функции.\
- Выявление скрытых дефектов: обнаружение дефектов, которые могли быть
введены в систему при изменении кода.]{.mark}

- **Чек-лист** - это упорядоченный список пунктов, которые необходимо
  проверить, выполнить или учитывать во время тестирования. Чек-лист
  служит для упрощения и структурирования процесса тестирования, помогая
  тестировщикам не забыть про важдные аспекты функциональности и сделать
  процесс проверки более систематичным и прозрачным.

[[Цели и задачи при составлении чек-листа:\]{.underline}
- Структурирование тестирования: чек-лист помогает организовать процесс
тестирования, разбивая его на отдельные, четко проделанные шаги или
пункты.\
- Обеспечение полноты покрытия тестами: гарантирует, что все важные
аспекты и функции системы будут проверены, помогает избежать пропуска
важных тестов.\
- Упрощение процесса тестирования: предоставляет готовый список пунктов
для проверки.\
- Повышение прозрачности: позволяет легко отслеживать процесс
тестирования и фиксировать, какие проверки были выполнены, а какие еще
нет.]{.mark}

- **Баг-репорт** - это обычные баг-репорты, оформленные в виде строки.
  Одна строка - один баг-репорт. Баг-репорт имеет все обязательные
  атрибуты, требующие корректного заполнения. В данной таблице нельзя
  вручную удалять столбцы, менять столбцы местами и переименовывать
  заголовки столбцов, так как это нарушит связи с другими таблицами.

[[Цели и задачи ведения баг-репортов:\]{.underline}
- Фиксация дефектов: описание найденных ошибок с указанием условий их
воспроизведения.\
- Улучшение коммуникации: обеспечение понятного обмена информацией между
тестировщиками, разработчиками и другими участниками команды.\
- Контроль исправлений: отслеживание статуса и истории багов на
протяжении всего жизненного цикла.\
- Повышение качества продукта: своевременное обнаружение и устранение
дефектов до выхода продукта пользователю.]{.mark}

Эталон Баг репорта

**Баг-репорт** --- это документ, описывающий ситуацию или
последовательность действий, приведших к некорректной работе объекта
тестирования, с указанием причин и ожидаемого результата.

Все пункты, отмеченные \"\*\", обязательны к заполнению.

**Пример баг-репорта:**

\*Заголовок: \"Sandbellow.Динамит.На карте Sandbellow при броске
динамита в одну сторону, он меняет свою траекторию полета, летит в
другую сторону\"

Билд v1.3

Чтобы было понятнее, обратите внимание на вложения

\*Шаги воспроизведения:

1.  Открыть игровой клиент.

2.  Кликнуть на кнопку \"multiplayer\".

3.  Кликнуть на кнопку \"host game\".

4.  Выбрать карту \"Sanbellow\".

5.  Метнуть динамит в любую сторону.

6.  Обратить внимание, в какую сторону улетит динамит.

\*Фактический результат: Динамит меняет траекторию полёта и летит в
другую сторону, не по своей траектории.

\*Ожидаемый результат: Динамит должен лететь по своей траектории, а не в
другую сторону.

\*[Ссылка](https://youtu.be/LqbBxxc2wlY)

#### **Шаблон баг-репорта**

Документ может отличаться в зависимости от проекта, но существуют
**обязательные поля**, которые везде примерно одинаковые.

  --------------------------------------------------------------------
  Поле                  Что содержит
  --------------------- ----------------------------------------------
  \*ID                  Числово-буквенное значение --- идентификатор
                        бага.

  \*Заголовок (title)   Суть проблемы. Должен быть ёмким и понятным.
                        Заголовок должен отвечать на 3 вопроса: **Что?
                        Где? Когда?**

  Описание              Обычно дублирует заголовок, поэтому не всегда
  (description)         обязательно. Однако можно описать проблему
                        более развёрнуто, если это необходимо.

  \*Шаги                Описание действий, которые нужно совершить,
  воспроизведения       чтобы воспроизвести баг.
  (steps)               

  \*Фактический         Что наблюдается после воспроизведения бага.
  результат (Actual     
  Result)               

  \*Ожидаемый результат Что на самом деле должно было произойти, как
  (Expected Result)     это должно работать согласно ТЗ.

  \*Окружение           Где был найден баг. Например, операционная
  (environment)         система, браузер или тестовая среда.

  \*Вложения (proofs)   Логи, скриншоты, скринкасты.

  Предусловия и         **Предусловие** --- описывает, как систему
  постусловия           нужно подготовить перед тестированием (в
  (pre-condition,       случае необходимости).\
  post-condition)       **Постусловие** --- указывает, как систему
                        нужно вернуть в прежний вид после тестирования
                        (в случае необходимости).

  Дополнительная        Например, пояснения от тестировщика: какие
  информация            способы ещё были опробованы для
  (additional info)     воспроизведения бага, и что получилось.

  Номер сборки (build)  Номер собранного билда, в котором был
                        обнаружен баг (например, 0.18.45).
  --------------------------------------------------------------------

#### **Описание специфичных элементов баг-репорта**

**Заголовок** должен отвечать на вопросы: \"Что\", \"Где\", \"Когда\".

Префиксы:

Для удобства баг-репорт может начинаться с префикса. Используются два
префикса, которые обозначают расширенное и узкое местоположение бага.

**Пример:** \"Sandbellow.Динамит.На карте Sandbellow при броске динамита
в одну сторону, он меняет свою траекторию полета, летит в другую
сторону\"

Как можно увидеть на этом примере, первым префиксом указана карта, а
вторым --- механика на карте. Из этих префиксов уже понятно, где
находится баг и с чем конкретно он связан. Нельзя использовать слишком
общие префиксы, такие как \"Maps. Weapons.\", так как это будет
означать, что баг происходит на любой карте и с любым оружием.

Баг-репорты необходимо описывать так, чтобы любой человек, прочитав их,
понял, в чём дело.

#### **Места хранения баг репортов**

В Appfox мы используем два основных места для хранения баг-репортов,
каждое со своими правилами. Это помогает нам эффективно отслеживать и
исправлять ошибки.

##### **Google Таблицы (Google Sheets)**

Первым и основным местом для баг-репортов является **специальная Google
Таблица**, созданная по
[ссылке](https://docs.google.com/spreadsheets/d/12caO1Q3oEuKLqaxWBgXE64CGT1spv1tR9IF92rhIcWA/edit?gid=1625903758#gid=1625903758).
В этой Google Таблице репортятся **все баг-репорты без исключения** для
дальнейшей приоритизации и исправления.

##### **Комментарии под задачей**

Вторым, не менее важным местом, являются **комментарии непосредственно
под задачей**. Здесь мы храним баг-репорты только в том случае, если
ошибка заключается в том, что **результат задачи не соответствует хотя
бы одному пункту** из [критериев
приемки](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/kriterii-priemki-IZT).
При таком несоответствии задача получает статус **\"Reopen\"** (баг
переоткрыт).

# Контроль поступающего контента

Контроль поступающего контента --- будь то графика, звук или видео ---
является важным этапом для обеспечения качества продукта. На этом этапе
проводится первичное изучение полученных материалов на предмет очевидных
ошибок.

#### **Изучение контента**

При получении контента от наших или сторонних художников,
звукорежиссёров, актёров озвучки, создателей визуальных эффектов и
других специалистов, проводится его первичное изучение на предмет
очевидных ошибок.

Техническое задание (ТЗ) имеет больший вес, чем общие критерии
оценивания. Таким образом, если в ТЗ написано, что необходим звук с
искажениями, будет нелогично требовать от звукорежиссёра отправить
\"чистый\" звук.

#### **Отчётность**

Обязательно заполняйте отчётность в рабочей таблице в соответствующих
графах о проделанной работе.

#### **Проверка UI/UX контента и вёрстки**

При проверке визуального контента и вёрстки уделяйте внимание следующим
аспектам:

- **Расположение элементов:** Проверяйте их расположение относительно
  друг друга и на сцене в целом.

- **Наличие необходимых элементов:** Убедитесь, что все элементы,
  предусмотренные дизайном, присутствуют.

- **Орфография и пунктуация:** Тщательно проверяйте текстовые элементы.

- **Размер и тип шрифта:** Убедитесь в соответствии шрифтов
  дизайн-макету.

- **Отступы:** Проверяйте отступы между символами и расстояние между
  строками текста.

- **Цветовая гамма:** Убедитесь в соответствии цветовой гаммы
  утверждённым стандартам.

- **Анимированные элементы:** Если присутствуют анимированные элементы,
  их также необходимо проверять на соответствие макетам и утверждённой
  анимации.

#### **Визуальное тестирование**

**Визуальное тестирование** --- это процесс проверки программного
обеспечения на соответствие графических элементов, изображений и
пользовательского интерфейса заданным требованиям и ожиданиям. Цель
этого вида тестирования --- убедиться, что пользователь видит информацию
корректно на любом устройстве, и что разработанный интерфейс совпадает с
дизайном, имеет правильные формы, положения элементов UI, размеры и
пропорции.

#### **Изображения**

Изображения тестируются согласно следующим основным пунктам:

- **Соответствие макету:** Особенно важно для окон меню и других
  ключевых элементов интерфейса.

- **Уровень качества:** Оцените, устраивает ли качество изображения
  заказчика, соответствует ли оно общему игровому стилю и уровню
  детализации проекта.

- **Присутствие всех элементов:** Убедитесь, что все элементы, которые
  есть в макете, присутствуют в готовом дизайне.

#### **Аудио**

Аудиоконтент согласовывается с заказчиком. Музыка и звуки должны
отвечать основным критериям:

- **Соответствие продолжительности.**

- **Соответствие качества звука** требованиям.

- **Соответствие стилю** другого звукового оформления в проекте.

**При проверке звука в игре:**

- **Голоса не должны накладываться и перебивать друг друга** (если это
  не было задумано по ТЗ).

- **Музыка не должна заглушать голоса персонажей** и звуковые эффекты.

#### **Видео**

Видео, как правило, вставляется в особые секции приложений или игр. Их
содержание должно отвечать требованиям, изложенным для конкретного видео
в ТЗ или запросе заказчика. В зависимости от содержания это может быть:

- Продолжительность видео.

- FPS (частота кадров).

- Разрешение.

- Качество.

- Сюжетное или визуальное наполнение.

- Соответствие спецэффектов.

#### **Остальной контент**

Прочий контент должен строго соответствовать запросам заказчика,
изложенным в ТЗ. Примерами такого контента могут быть:

- Анимации.

- Визуальные эффекты.

- Переводы текстов.

- Интеграция сторонних ресурсов в проект.

# Критерии приемки

**Критерии приёмки** --- это ключевые условия, по которым задача может
считаться полностью выполненной и закрытой. Они служат руководством для
команды и гарантией удовлетворения требований заказчика.

Проектный менеджер должен описывать критерии приёмки **от лица
игрока/пользователя**. Основным критерием для успешного приёмочного
тестирования является именно выполнение требований заказчика.

#### **Важность чётких критериев приёмки**

Хорошо сформулированные критерии приёмки помогают избежать неожиданных
результатов в конце этапа разработки. Они гарантируют, что все
заинтересованные стороны и конечные пользователи останутся довольны
полученным продуктом.

Важный аспект: критерии приёмки необходимо определить **до того**, как
команда разработчиков начнёт работу над конкретной пользовательской
историей. В противном случае существует значительный риск того, что
результаты работы не будут соответствовать нуждам и ожиданиям клиента.

#### **Пример критериев приёмки**

Название задачи: \"Механика ежедневных наград\".

Описание задачи: \"Как игрок, я хочу получать награды после первого
логина за день\".

**Критерии приёмки:**

- При первом запуске игры за день система показывает игроку ежедневное
  всплывающее окно, в котором он может забрать награду.

- Шаг получения награды не может быть пропущен. Если игрок закрывает
  игру до получения награды, ему снова прилетит всплывающее окно для
  получения награды при следующем запуске.

- На попапе игрок может видеть прогресс ежедневной награды (например, 7
  дней, каждый день новая награда).

- Прогресс ежедневной награды сбрасывается, если игрок пропустил день.

- Когда игрок прошёл всю прогрессию по ежедневным наградам, она
  сбрасывается, и прогресс начинается сначала.

- Может быть замокано, то есть сделано только на фронтенде без бэкенда.

После того как программист изучил критерии приёмки, он уведомляет о
количестве времени, которое ему потребуется на эту реализацию.

#### **Когда нужны критерии приёмки?**

Отборочные критерии пишутся не для каждой задачи. Их необходимость
определяется **сложностью задачи**, которая, в свою очередь, часто
определяется **временем её выполнения**. Чем сложнее и дольше задача,
тем важнее чёткие критерии приёмки.

# Виды Тестирования ПО

Прежде чем приступить к любому виду тестирования, команда составляет
**план тестирования**. В нём определяются цели, стратегии, ресурсы,
инструменты и критерии приёмки. Это помогает организовать процесс
тестирования и избежать хаоса. Тестирование должно соответствовать этапу
жизненного цикла разработки продукта.

##### **Виды тестирования по жизненному циклу ПО (с определениями и примерами)**

# Методы тестирования ПО

В процессе обеспечения качества программного обеспечения (ПО)
используются различные методы тестирования, каждый из которых имеет свою
специфику, области применения, преимущества и недостатки. Понимание этих
методов поможет тебе выбирать наиболее эффективный подход для конкретной
задачи.

#### **Чёрный ящик (Black-box testing)**

**Суть:** Тестирование без знания внутреннего устройства системы. Работа
ведётся исключительно через внешний интерфейс или API. Не важно, как
реализована логика внутри --- важно, чтобы система работала правильно с
точки зрения пользователя.

**Когда использовать:**

- Проверка UI (пользовательского интерфейса) и UX (пользовательского
  опыта) на всех платформах.

- Проверка бизнес-логики (например, процесс покупки, регистрация
  пользователя).

- Проверка API через внешние инструменты, такие как Swagger или Postman.

- Проведение Smoke-тестирования (быстрая проверка базовой
  функциональности) и регрессионного тестирования (проверка того, что
  новые изменения не нарушили существующую функциональность).

- Тестирование сторонних SDK, к которым нет доступа к исходному коду.

**Пример:** Проверяем механику покупок в игре: покупаем за золото
предмет, убеждаемся, что золото списалось, а предмет появился в
инвентаре.

  --------------------------------------------------------------------
  Плюсы                      Минусы
  -------------------------- -----------------------------------------
  Не нужно знать код.        Нельзя проверить, почему именно возник
                             баг.

  Идеален для тестов глазами Меньший охват логики (не видно, какие
  пользователя.              ветки кода работают или нет).

  Может выполнять даже       
  junior-тестировщик.        
  --------------------------------------------------------------------

#### **Белый ящик (White-box testing)**

**Суть:** Тестирование с полным доступом к исходному коду и пониманием
внутренней логики системы. Применяется чаще всего при автоматизации и
юнит-тестировании (проверке отдельных модулей кода).

**Когда использовать:**

- Написание юнит-тестов для проверки корректной работы конкретного
  метода или функции.

- При работе с CI/CD (непрерывная интеграция/непрерывная доставка) для
  покрытия кода и статического анализа.

- Оптимизация сложной бизнес-логики.

- Автоматизированное тестирование бэкенда (включая базу данных,
  сервисную логику).

**Пример:** Проверяем, что метод начисления награды за миссию правильно
отрабатывает при разных значениях опыта игрока, проверяя код, который
выполняет эти расчёты.

  -------------------------------------------------------------------
  Плюсы          Минусы
  -------------- ----------------------------------------------------
  Максимальный   Нужны глубокие знания кода, внутренней логики и
  охват логики.  используемого языка программирования.

  Легче найти    Малоэффективен для тестов с точки зрения конечного
  точную причину пользователя.
  дефекта.       

  Помогает       Трудно поддерживать такое тестирование, поскольку
  улучшить       требуются специализированные инструменты
  качество кода. (анализаторы кода, отладчики) и постоянная
                 актуализация.
  -------------------------------------------------------------------

#### **Серый ящик (Gray-box testing)**

**Суть:** Комбинация подходов \"чёрного\" и \"белого\" ящиков.
Тестировщик знает архитектуру системы и может заглянуть во внутренние
логи, запросы к БД, но при этом не пишет и не меняет код. Часто
используется для тестирования API, безопасности и интеграций.

**Когда использовать:**

- Проверка взаимодействия клиента и сервера.

- Тестирование API и промежуточного ПО (middleware).

- Тестирование безопасности (например, валидность токенов, права
  доступа).

- Проверка запросов через прокси-инструменты, такие как Charles или
  Proxyman, и анализ ответов от бэкенда.

**Пример:** Проверяем, что запросы при авторизации клиента шифруются,
что access token обновляется корректно, и что при просрочке access token
выдается нужная ошибка, анализируя сетевой трафик и логи сервера.

  --------------------------------------------------------------------
  Плюсы                                 Минусы
  ------------------------------------- ------------------------------
  Баланс между знанием внутренней       Нельзя проверить логику на
  структуры и наблюдением за работой    уровне исходного кода.
  системы.                              

  Позволяет составить эффективные тесты Требуется больше знаний, чем
  по логике данных, не требуя доступа к при тестировании \"чёрного
  коду.                                 ящика\".

  Отличный подход при ручном            
  тестировании API и баз данных.        
  --------------------------------------------------------------------

#### **Ручное тестирование**

**Суть:** Проверка функциональности программного обеспечения вручную,
без написания автоматизированных скриптов. Используется там, где важна
визуальная часть, или сложно/невыгодно автоматизировать процесс.

**Когда использовать:**

- UI/UX тестирование (проверка \"Pixel Perfect\" соответствия макетам,
  анимаций, багов вёрстки).

- Проверка сложных пользовательских сценариев с множеством комбинаций
  действий.

- Проведение исследовательского тестирования (свободное исследование
  функционала для поиска неочевидных ошибок).

- Проверка новых фич и функционала перед написанием автотестов.

**Пример:** Проверяем в iOS-версии игры корректность открытия всех окон
магазина, их адаптивность к различным устройствам и правильное
отображение скидок на товары.

  --------------------------------------------------------------------
  Плюсы                           Минусы
  ------------------------------- ------------------------------------
  Гибкость, позволяет быстро      Зависимость от человеческого фактора
  найти баги.                     (утомляемость, невнимательность).

  Хорошо подходит для проверки    Менее эффективно для регрессионного
  новых фич и нестандартных       тестирования (долгая и рутинная
  сценариев.                      проверка).

                                  Затратно по времени и ресурсам при
                                  повторениях.
  --------------------------------------------------------------------

#### **Автоматическое тестирование**

**Суть:** Написание и запуск специальных скриптов или программ, которые
автоматически проверяют функциональность системы. Используется для
постоянных и повторяющихся проверок.

**Когда использовать:**

- Проверка стабильности и регрессионное тестирование после каждого
  нового билда.

- Проверка API, логики авторизации, сложных расчётов.

- Проверка кросс-браузерной или кросс-платформенной совместимости.

- Performance-тестирование (проверка производительности) и
  Load-тестирование (проверка поведения под нагрузкой).

**Пример:** После каждого билда запускаются автотесты API (например, на
Python с использованием PyTest), которые автоматически проверяют функции
логина, регистрации, операции CRUD (создание, чтение, обновление,
удаление) с инвентарём пользователя и выполнение ежедневных заданий.

  -------------------------------------------------------------------
  Плюсы                           Минусы
  ------------------------------- -----------------------------------
  Экономит время и ресурсы при    Требует значительных начальных
  регрессионном тестировании.     вложений времени на внедрение и
                                  постоянную поддержку.

  Легко интегрируется в           Невыгодно автоматизировать
  CI/CD-процессы.                 нестабильные или часто меняющиеся
                                  фичи.

  Можно запускать ночью или по    
  расписанию, освобождая время    
  для других задач.               
  -------------------------------------------------------------------

### **Когда и что использовать: Краткая шпаргалка**

  ---------------------------------------------------------------------
  Сценарий           Метод           Почему?
                     тестирования    
  ------------------ --------------- ----------------------------------
  Проверка новой     Ручное +        Для оценки UI, UX, логики и поиска
  фичи               Black-box       ошибок глазами пользователя.

  Проверка API после Gray-box +      Для сравнения ответов, кодов
  фикса              Автоматизация   статусов и данных в базе данных.

  Оптимизация логики White-box       Требуется проверка внутренней
  расчётов                           реализации и алгоритмов.

  Smoke-тест после   Black-box +     Быстро убедиться, что базовый
  билда              Автоматизация   функционал работает (\"всё
                                     живо\").

  Проверка           Gray-box        Для анализа запросов, ответов и
  взаимодействия                     серверных логов.
  клиент-сервер                      

  Ежедневный регресс Автоматизация   Для быстрого и надёжного покрытия
                     (Black/White)   критичного функционала.

  UI/UX фидбек       Ручное          Для проверки продукта с точки
                     (Black-box)     зрения конечного пользователя и
                                     его восприятия.
  ---------------------------------------------------------------------

# Техники тест-дизайна

# Работа с билдами

#### **Пошаговая инструкция \"Что делать с билдом?\"**

##### **Новый билд**

##### 

Бросая новый билд в специальный чат, разработчик прикладывает описание к
билду, содержащее:

- Что было изменено, добавлено.

- Список того, что могло быть задето разработкой.

- Ссылку на задачу или задачи, в которых велась разработка.

В следующем формате:

- Ссылка на задачу (задачи), в которой велась разработка.

- Список механик, которые были исправлены (добавлены) в данном билде \*.

- Список механик, которые могли быть затронуты.

- Уведомление QA в сообщении с билдом \*.

Все пункты с \"\*\" обязательны к заполнению.

**Пример с рабочего проекта:**

![image.png](./media/image25.png){width="6.267716535433071in"
height="4.736111111111111in"}

#### **Приемочное тестирование**

- Перед приёмом билда на подробное тестирование, QA команда проводит
  \"приемочное тестирование\" (поверхностные тесты на наличие
  блокирующих ошибок).

- В случае обнаружение такого рода ошибок, билд должен быть отвергнут QA
  командой от дальнейшего тестирования до момента устранения блокирующих
  ошибок.

В начале теста билда и в его процессе, а также после завершения должны
быть коммуникации, которые должны проходить в треде под билдом.\
\
Есть принятые шаблоны общения по билду:\
- Билд взят на приемочное тестирование.\
- Приемочное тестирование проведено, билд принят и будет подробно
протестирован.\
- Найдена блокирующая ошибка -- пока не исправите, не смогу дать
одобрение на слияние.\
- Блокеров не найдено, даю [[одобрение на
слияние.]{.underline}](https://wiki.appfox.ru/books/akademiya-qa-2-uroven/page/odobrenie-funkcionalnoi-vetki-pered-sliyaniem-v-osnovnuyu-vetku)

# Одобрение функциональной ветки перед слиянием в основную ветку

Этот регламент применяется на проектах, где задействовано **два
программиста и более**. Он описывает процесс одобрения функциональных
веток (\"фича бранчей\") перед их слиянием в основную ветку разработки,
что критически важно для поддержания стабильности и качества кода.

#### **Инструкция**

После выполнения задачи разработчик собирает билд со своей \"фича
бранчи\" и **не проводит слияние до получения одобрения от QA**.

- Существуют задачи на \"фича бранчах\", для которых сбор билдов не
  требуется. Тип таких задач определяет разработчик. Если билд не нужен,
  тестирование проводится непосредственно в **Unity Редакторе**.

#### **Требования к тесту на фича бранчах**

Тестирование на функциональных ветках должно включать:

- **Подробный тест разработанного функционала** и всех модулей, которые
  он затрагивает.

- **Смок-тест** (\"Дымовой тест\") --- поверхностная проверка основных
  механик, чтобы убедиться в их работоспособности.

#### **Как происходит одобрение ветки**

На каждом Discord-сервере проекта присутствует специальный чат для
билдов. Как только разработчик выкатывает билд, он отправляется в этот
чат.

**Правила одобрения QA:**

- Одобрение QA делается **только в треде под билдом**.

- Формулировка одобрения должна быть следующей: **\"Успешно
  протестировано, блокеры отсутствуют\"**.

- **Разработчик сам решает**, какая ветка нуждается в одобрении QA.

- Как только программист получил одобрение от QA, он может проводить
  слияние в основную ветку.

#### **Тест, который должен проводить разработчик**

Перед отправкой билда или деплоем изменений на сервер разработчик должен
провести собственный тест:

- **Только что созданный билд** должен быть запущен разработчиком, чтобы
  убедиться в отсутствии критических блокеров, которые могли бы помешать
  тестировщику провести полноценное тестирование.

- **Изменения на сервере**, которые могут привести к блокирующим
  ошибкам, также должны быть протестированы **смок-тестом разработчика**
  после деплоя.

#### **Правила для Разработчика**

- Перед отправкой билда или деплоем изменений на сервер сделайте
  **смок-тест, который займёт не более 5 минут**. Это обеспечит
  отсутствие блокеров для тестировщика.

- Когда тест успешно проведён, можно отправлять билд в специальный чат
  на сервере проекта.

- В сообщении с билдом/деплоем **обязательно нужно уведомить
  тестировщиков**.

# Статусы задач и путь баг репорта

Если в проверенной задаче есть баги, не связанные с критериями приемки,
то задача может быть закрыта, а баги помещены в таблицу баг репортов.

- **Пример комментария к выполненной задаче\**
  ![image.png](./media/image10.png){width="5.322916666666667in"
  height="2.6979166666666665in"}**\**

Проверенная задача, в которой найдено несоответствие хотя бы с одним
критерием приемки, возвращается назад в статус \"*В процессе*\". Все
несоответствия должны быть указаны в комментариях под задачей, а
найденные баги должны быть перенесены в таблицу с багами.

- **Пример комментария к задаче с неудовлетворительным результатом\**
  ![image.png](./media/image30.png){width="5.375in"
  height="3.1666666666666665in"}

Все возможные шаблоны с комментариями к задаче можно копировать из
\"[Рабочей таблицы
QA](https://docs.google.com/spreadsheets/d/1rHTXrOE8tSTSz41rYOGXo1EsB8vppiTdw0qqIu52g8U/edit?gid=663556553#gid=663556553)\"
и, изменяя данные, отправлять комментарием к задаче:

![image.png](./media/image6.png){width="6.267716535433071in"
height="1.3194444444444444in"}

Важно: по результатам проведенных проверок тестировщику необходимо
оставить полнноценный комментарий о ходе проверок с результатами.

##### **Схема статусов задач:**

![1111111.png](./media/image29.png){width="6.267716535433071in"
height="2.1805555555555554in"}

##### **Схема пути баг репортов:**

![00000.jpg](./media/image24.jpg){width="6.267716535433071in"
height="3.236111111111111in"}

1.  *Отклонен Пмом т.к. не баг*

2.  *В работе*

3.  *Отклонен Разработчиком т.к. не баг*

4.  *Исправлен и поэтому отправлен на проверку*

5.  *Переоткрыт т.к. баг не исправлен*

6.  *Закрыт т.к. баг исправлен*

7.  *Переоткрыт т.к. у бага рецидив после исправления*

# Тестирование по ГДД

Геймдизайн-документ (ГДД) или Техническое задание (ТЗ) --- это документ
с очень детальным описанием проекта. Если поставлена задача
протестировать определённую механику, нет необходимости дёргать
Проектного менеджера (ПМ) по каждому вопросу; скорее всего, ответ уже
есть в этом документе.

Рассмотрим ситуацию: сотруднику Ивану поручили протестировать
авторизацию. Иван видит, что механика работает, но отсутствует
авторизация через Facebook, заявленная в ГДД. Вместо того чтобы сразу
пинговать ПМа или разработчиков, или заводить баг-репорт, Иван сначала
проверяет в рабочей таблице, планировалась ли реализация этой механики
на данном этапе разработки. Только в случае, если нужная информация не
найдена, он обращается к ПМу.

Есть две весомые причины для обращения к ПМу:

- Не найдена необходимая информация (поскольку её, возможно, просто
  нет).

- Задачи по тестированию \"горят\", и нет времени на поиск.

Всю необходимую информацию необходимо получить от коллег до начала
тестирования, но следует учитывать нестандартные ситуации и человеческий
фактор.

#### **Проверка функционала на соответствие техническому заданию**

При проведении тестирования функционала тестировщик обязан опираться
исключительно на утверждённое техническое задание - основное и (при
наличии) дополнительное.

Если проверяемый функционал **не описан в ТЗ**, тестировщик инициирует
процесс актуализации документации. Возможны следующие варианты:

Функционал относится к дополнительным работам, на которые уже оформлен
дополнительный документ (допник) --- необходимо обеспечить его привязку
к основному ТЗ.\
\
- Работы выполнены и согласованы, но дополнительного соглашения нет -
требуется запрос на оформление допника.\
\
- Функционал не описан или описан недостаточно подробно в основном ТЗ -
необходимо подать заявку на внесение изменений и уточнение описания.

**Без актуального ТЗ проверка считается недостоверной.**

#### **Покраска ГДД**

Покраска ГДД (или ТЗ) выполняется построчно по следующему алгоритму:

- **Без цвета:** Задача ещё не начиналась.

- **Жёлтый цвет:** Задача в процессе или находится на проверке.

- **Красный цвет:** Задача под вопросом или её реализация не
  планируется.

- **Зелёный цвет:** Задача полностью выполнена.

Следует понимать, что покраска ГДД требует **обязательного участия
разработчиков**.

**Цель задачи по покраске ТЗ/ГДД:**

- Выявить проблемные места проекта.

- Выявить соответствие реализации проекта заявленным в документе
  требованиям и срокам.

Покраска ГДД выполняется по завершении тестирования задачи \"на
проверке\" (приоритетно), завершении этапа или спринта.

*Пример:*

![image.png](./media/image27.png){width="6.267716535433071in"
height="4.444444444444445in"}

#### **Покраска ТЗ и ДОПников, оценка задач на соответствие техническому заданию и фиксация отходов от ТЗ**

**1. Покраска ТЗ после проверки задачи\**
После завершения тестирования задачи тестировщик обязан сразу же
отметить соответствие выполненного функционала пункту технического
задания (ТЗ). Это делается путём добавления в комментарий к задаче
шаблонной фразы с указанием пункта ТЗ, например:\
\`Покраска в ТЗ: пункт 2.1.1\`\
Комментарий добавляется как при закрытии задачи, так и при возврате её в
доработку.\
Шаблоны комментариев находятся в [\"Рабочей таблице QA
отдела\"](https://docs.google.com/spreadsheets/d/1rHTXrOE8tSTSz41rYOGXo1EsB8vppiTdw0qqIu52g8U/edit?gid=663556553#gid=663556553)

![image.png](./media/image13.png){width="5.666666666666667in"
height="2.4027777777777777in"}

**2. Фиксация отсутствия описания или ДОПников в ТЗ\**
Если в процессе тестирования выясняется, что в ТЗ отсутствует описание
проверяемого функционала, а сам функционал присутствует в продукте,
тестировщик обязан зафиксировать это в таблице \"Рабочей таблице QA
отдела\" в разделе, посвящённом отходам от ТЗ и отсутствующим ДОПникам:
лист [\"Еженедельная сводка по проектам\"\
](https://docs.google.com/spreadsheets/d/1rHTXrOE8tSTSz41rYOGXo1EsB8vppiTdw0qqIu52g8U/edit?gid=517602915#gid=517602915)Это
касается всех случаев, когда:\
- Функционал реализован, но не описан в основном ТЗ;\
- Работы явно выходят за рамки текущего объёма ТЗ, но при этом нет
дополнительного соглашения (ДОПника);\
- Есть согласованный ДОПник, но он не прикреплён или не учтён в
структуре документации.

![image.png](./media/image14.png){width="6.267716535433071in"
height="0.7361111111111112in"}

**3. Регулярность и прозрачность покраски\**
Важно обеспечивать регулярную покраску ТЗ и ДОПников, особенно по
завершении каждого спринта.\
Если проект не покрыт покраской ТЗ либо информация обновляется
нерегулярно, это необходимо оперативно устранить.\
Актуальность покраски проверяется через таблицу \"[Сводка по наличию и
покраске ТЗ и
ДОПников](https://docs.google.com/spreadsheets/d/1iSvuAyeUbtKvC57NaJLcPBnRJVEmfMeQCJpNaf_dNWE/edit?gid=0#gid=0)\"

![image.png](./media/image28.png){width="6.267716535433071in"
height="1.4027777777777777in"}

# Программы для работы

#### **Во время работы тебе могут пригодиться следующие программы**

# Тестирование вёрстки

При тестировании правильности верстки веб-сайта или приложения,
**тестировщик проводит сопоставление расположения всех элементов**.
Необходимо проверять, как размерность каждого элемента, так и их
правильное расположение на веб-странице или экране приложения в
соответствии с согласованными ранее макетами. При тестировании верски
нужно обращать внимание на соответствие макету, на наличие адаптива для
всех популярных соотношений сторон и разрешений устройств, а также на
техническую составляющую.

**Как проводить тестирование вёрстки:**

# Как снять logs (журнал событий) с мобильного устройства

Снятие журнала событий (логов) с мобильных устройств --- важный навык
для тестировщика, позволяющий получить подробную информацию о работе
приложения и возникающих ошибках.

#### **Android**

Чтобы снять логи с устройства Android, убедитесь, что **режим
USB-отладки** активирован в настройках устройства.

**Как активировать режим USB-отладки:**

1.  Откройте меню **\"Настройки\"**.

2.  Нажмите на раздел **\"О телефоне\"** или **\"О планшете\"**.

3.  Выберите **\"Информация о программном обеспечении\"**.

4.  Продолжайте нажимать на **\"Номер сборки\"**, пока не появится
    уведомление о том, что функции разработчика теперь доступны.

5.  Вернитесь в меню **\"Настройки\"**.

6.  Выберите **\"Для разработчиков\"**.

7.  Активируйте режим **USB-отладки**.

**Шаги для получения логов через ADB (Android Debug Bridge):**

1.  **Установите ADB** (Android Debug Bridge) на свой компьютер.

2.  **Подсоедините устройство** к компьютеру через USB.

3.  **Подтвердите подключение** на мобильном устройстве.

4.  Откройте **командную строку Windows**.

5.  Введите команду adb devices для проверки подключения.

6.  Введите команду adb logcat \>
    путь_к_месту_сохранения_файла\\log1.txt (замените
    путь_к_месту_сохранения_файла на желаемый путь).

7.  **Воспроизведите проблему** на устройстве.

8.  **Остановите процесс** снятия логов, нажав Ctrl+C в командной
    строке, или просто отсоедините устройство.

9.  Файл log1.txt с логами устройства будет находиться в папке, из
    которой вы запустили консоль, или по указанному пути.

Также можно просматривать логи через **Unity**, используя фильтр. При
этом **режим разработчика** на устройстве и **USB-отладка** должны
оставаться активированными.

#### **iOS**

Для снятия логов с устройств iOS на Windows используйте приложение
**iMazing**.

**Шаги для получения логов через iMazing:**

1.  **Установите приложение iMazing.**

2.  **Подключите устройство по USB** к компьютеру.

3.  В меню iMazing выберите **\"Показать консоль устройства\"**.

В консоли iMazing можно:

- **Фильтровать** выводимые логи, чтобы сосредоточиться на нужной
  информации.

- **Остановить поток** входящих логов кнопкой \"пауза\" для детального
  анализа.

- **Сохранять логи** с помощью соответствующей кнопки.

Эти функции помогут сконцентрироваться на логах конкретного запущенного
приложения.

# Туториал по тестированию адаптивности верстки на разных разрешениях

![image.png](./media/image22.png){width="6.267716535433071in"
height="1.6388888888888888in"}

Цель этого руководства --- помочь в проверке корректного отображения
элементов интерфейса мобильных приложений, игр и веб-сайтов на экранах с
различными разрешениями. Важно убедиться, что вёрстка адаптируется без
критических багов, а все элементы остаются удобными для взаимодействия.

#### **Проверяем поведение элементов при изменении разрешения**

При тестировании адаптивности необходимо наблюдать, как элементы
интерфейса ведут себя на экранах разных размеров:

- **Широкие экраны** (например, iPad mini):

  - Основной контейнер заполняет всё доступное пространство по ширине.

  - Внешние отступы увеличиваются, если ширина экрана превышает
    определённый порог.

  - Внутренний контент центрируется.

  - Если элемент имеет фиксированную ширину, по краям могут появляться
    пустые области или белые полосы.

- **Средние экраны** (например, iPhone 15 Pro Max, Android Compact):

  - Контейнер сжимается, приближаясь к пропорциям экрана.

  - Элементы внутри сохраняют свои относительные размеры, но могут
    становиться более узкими.

  - Возможны изменения цвета или прозрачности из-за изменений фоновых
    слоёв.

- **Узкие экраны**:

  - Контейнер уменьшается, сохраняя пропорции, но возможны проблемы с
    размещением элементов.

  - Вложенные элементы могут сжиматься или накладываться друг на друга.

  - Возможно обрезанное содержимое, если его размеры не адаптируются
    динамически.

![image.png](./media/image21.png){width="3.5972222222222223in"
height="2.25in"}

#### **Критерии проверки**

- Элементы не выходят за границы контейнера.

  Нет наложения или скрытия важных элементов.

  Адаптивная верстка корректно изменяет отступы и размеры.

  Контент остается читабелдьным и доступным на всех разрешениях.

  Область действия кнопок, полей и т.д. остается корректной.

#### **Потенциальные баги и их признаки**

#### **Что делать, если обнаружили баг?**

1.  Сделать скриншот с указанием устройства и его разрешения.

2.  Описать поведение элементов: как именно они перемещаются или
    отображаются некорректно.

3.  Сравнить с ожидаемым результатом (по макету в Figma или по логике
    адаптации)

4.  Завести баг-репорт с подробностями (устройство, ОС, версия
    браузера/приложения и т.д.) и заполненными обязательными атрибутами.

# Туториал по GIT и Unity

Этот туториал содержит подробные инструкции по развёртыванию проекта для
тестирования в Unity из GitLab. Он поможет эффективно клонировать
репозиторий, настроить проект в Unity и выполнять необходимые
обновления.

![image.png](./media/image11.png){width="3.2777777777777777in"
height="2.4166666666666665in"}

#### **Предварительная подготовка**

Перед началом работы **уточните у разработчика номер сборки Unity**, на
которой работает проект. **Установите соответствующую версию Unity**
через Unity Hub, если она ещё не установлена.

#### Шаги для клонирования и настройки проекта:

**1. Клонирование репозитория из GitLab:\**
 - В командной строке выполните команду для клонирования репозитория:\
git clone \<ссылка на репозиторий\>\
- \<ссылка на репозиторий\> --- это URL проекта (например,
https://gitlab.com/your-group/your-project.git).\
- Эта команда копирует удалённый репозиторий на ваш компьютер.

**2. Переход в папку проекта:\**
 - Перейдите в директорию с клонированным репозиторием:\
cd \<путь к папке проекта\>

**3. Получение информации об удалённых ветках:\**
 - Обновите информацию о доступных ветках:\
git fetch origin

**4. Создание и переключение на нужную ветку (например, Dev):\**
 - Если вам нужна ветка Dev, выполните команду:\
git checkout -b Dev origin/dev

**5. Обновление всех подмодулей:\**
 - Если проект использует подмодули, обновите их:\
git submodule update \--init \--recursive

**6. Проверка статуса изменений:\**
 - Проверьте состояние рабочей директории:\
git status

**7. Сохранение локальных изменений (если необходимо):\**
 - Сохраните локальные изменения во временном хранилище:\
git stash save -u

**8. Обновление проекта из удалённого репозитория:\**
 - Загрузите последние изменения из удалённого репозитория:\
git pull

#### **Открытие проекта в Unity**

**1. Откройте Unity через Unity Hub:\**
 - Выберите *Open* и укажите путь к папке с клонированным проектом.\
- Убедитесь, что версия Unity соответствует требуемой для проекта. Если
Unity предложит обновить какие-либо плагины или пакеты, согласитесь и
дождитесь завершения установки.

**2. Переключение платформы на Android:\**
 - Откройте *File* \> *Build Settings*.\
- В разделе *Platform* выберите *Android*.\
- Нажмите *Switch Platform*.\
- Подождите, пока Unity завершит переключение платформы.

**3. Решение возможных ошибок в консоли:\**
 - После переключения на Android в *Console* Unity могут появиться
ошибки.\
- Прочитайте текст ошибок внимательно и выполните необходимые действия
для их устранения:\
- Возможно, потребуется установить дополнительные Android SDK, NDK или
Gradle, если они отсутствуют. Unity автоматически предложит их
установить, если это необходимо.\
- Проверьте, не требуют ли плагины и зависимости обновлений или
дополнительных настроек для Android-платформы.

#### **Команды для обновления проекта при изменениях**

Если проект был обновлён в репозитории, выполните следующие команды:

**1. Перейдите в папку проекта:\**
cd \<путь к папке проекта\>

**2. Сохраните локальные изменения (если есть):\**
git stash save -u

**3. Обновите ветку, получив последние изменения:\**
git pull

**4. Обновите подмодули (если изменения были и в них):\**
git submodule update \--init \--recursive

**5. Проверка статуса изменеий\**
git status

#### **Возможности тестирования в Unity**

После успешного выполнения всех вышеуказанных шагов проект готов к
тестированию. В Unity вы можете выполнять следующие задачи:

- **Тестирование разрешения экранов:** Проверьте отображение интерфейса
  на различных разрешениях и соотношениях сторон, чтобы убедиться в
  корректной адаптивности.

- **Запуск в режиме Playmode:** Тестируйте игровой процесс,
  пользовательский интерфейс (UI), анимации и эффекты непосредственно в
  редакторе Unity.

- **Проверка производительности:** Используйте встроенный **Unity
  Profiler** для анализа частоты кадров (FPS), использования памяти и
  других ресурсов, чтобы выявить \"узкие места\".

- **Проверка ошибок и логов:** Анализируйте окно **Console** Unity для
  выявления ошибок и предупреждений, что поможет понять причины сбоев.

- **Тестирование пользовательского интерфейса:** Оцените работу и
  отображение элементов UI на платформе Android, уделяя внимание
  удобству взаимодействия и визуальной части.

Эти шаги помогут корректно развернуть проект для тестирования в Unity и
успешно переключиться на платформу Android для проведения необходимых
проверок.

# Туториал по работе с PerfectPixel

#### **1 Шаг:**

Установите [расширение
PerfectPixel](https://chromewebstore.google.com/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=ru)
в браузер, сделайте его активным и отметьте \"скрепочкой\"

![image.png](./media/image20.png){width="2.1666666666666665in"
height="3.6805555555555554in"}

#### **2 Шаг:**

Откройте Figma проекта и переключитесь на режим разработчика. Выделите
нужный макет экрана и справа посмотрите, какой у него разрешение.

![image.png](./media/image26.png){width="6.267716535433071in"
height="3.125in"}

#### **3 Шаг:**

Откройте билд (приложение, сайт) в том разрешении, которое указано в
макете. Сделайте скриншот того экрана (сохраните его на локальном
диске), верстку которого хотите сравнить с Figma. Для открытия в нужном
разрешении можно использовать эмуляторы или открыть проект в редакторе
Unity.

#### **4 Шаг:**

Находясь на странице с макетом Figma, нажимет на икноку расширения
PerfectPixel в верхней панели браузера

#### ![image.png](./media/image9.png){width="4.21875in" height="3.96875in"}**5 Шаг:**

Нажмите \"Добавьте ваш первый слой\" в открывшемся окне и загрузите
скриншот экрана в нужно разрешении из эмулятора или Unity. После этого
наложите свой слой со скриншотом на макет тестируемого экрана и сравните
расположение элементов. Используйте инструмент \"Прозрачность\", чтобы
увидеть, в каких местах есть расхождения. Также PerfectPixel позволяет
добавить изображение из буфера обмена или добавить ссылку на изображение

![image.png](./media/image23.png){width="2.125in"
height="3.5208333333333335in"}

####  

#### **Триггеры при тестировании верстки по макету из Figma**

При тестировании Pixel Perfect важно обращать внимание на **ключевые
расхождения**, которые могут повлиять на пользовательский опыт. Вот
основные **триггеры**, которые помогут выявить проблемы.

**1) Расположение элементов**

Что проверяем:\
- Кнопки, иконки, заголовки, поля ввода, текст должны **совпадать с
макетом**.\
- Элементы должны быть **на одном и том же месте** на разных экранах
(например, кнопка \"Назад\" всегда слева сверху).\
- Проверяем **выравнивание** (по центру, по краю, по сетке).

Допустимое отклонение:\
**±2 px** --- допустимо из-за особенностей рендеринга браузеров.\
**\>2 px** --- если элемент \"прыгает\", требует исправления.

**2) Отступы и размеры**

Что проверяем:\
- Отступы между элементами и до края экрана должны **точно
соответствовать макету**.\
- Внутренние отступы (padding) и внешние (margin) должны быть
одинаковыми.\
- Элементы в одном блоке должны **сохранить пропорции**.

Допустимое отклонение:\
**±2 px** --- допустимо.\
**\>2 px** --- проверяем код (margin, padding, gap).

**3) Шрифты и их отображение**

Что проверяем:\
- Шрифт соответствует макету **(название, стиль, размер, жирность)**.\
- Межбуквенный интервал (letter-spacing) и высота строки (line-height)
не изменены.\
- Разные браузеры и ОС могут **рендерить шрифты немного иначе**, но
сильные отличия недопустимы.

Допустимое отклонение:\
**±1 px** --- иногда браузер рендерит шрифт чуть больше или меньше.\
**\>1 px** --- возможна ошибка в font-size или line-height.

**4) Цвета и прозрачность**

Что проверяем:\
- Цвет фона, текста, кнопок, теней **точно совпадает** с макетом.\
- Прозрачность элементов (opacity) соответствует дизайну.\
- Нет случайных изменений оттенков.

Допустимое отклонение:\
**0%** --- цвета должны быть **точно такими же**.\
Проверяем в DevTools (color picker).

**5) Иконки и изображения**

Что проверяем:\
- Используются **SVG**, если в макете вектор.\
- Картинки не **размытые**, не **сжаты** и не растянуты.\
- Масштабирование иконок не нарушено.

Допустимое отклонение:\
**Если иконка отличается --- проверяем формат (PNG vs. SVG).**

**6) Адаптивность и брейкпоинты**

Что проверяем:\
- Элементы адаптируются правильно при изменении ширины экрана.\
- На разных разрешениях (320px, 768px, 1024px) нет сломанных отступов.\
- Верстка не «едет» при изменении масштаба.

Допустимое отклонение:\
Если блоки перескакивают не так, как в макете --- проблема в flex/grid.

**7) Интеррактивные элементы**

Что проверяем:\
- Кнопки, ссылки, поля ввода работают **как задумано**.\
- Анимации и эффекты ховера совпадают с макетом.\
- Нет \"мертвых зон\", где клик не срабатывает.

Допустимое отклонение:\
Эффекты могут немного отличаться, но UX должен быть **одинаковым**.

# Модели разработки ПО

В процессе создания программного обеспечения используются различные
модели разработки. Каждая из них имеет свои особенности, преимущества и
недостатки, определяющие её применимость к конкретным типам проектов.
Понимание этих моделей помогает выбрать наиболее эффективный подход и
управлять ожиданиями.

##### **«Waterfall Model» (каскадная модель или «водопад»)**

![image.png](./media/image31.png){width="5.402777777777778in"
height="3.361111111111111in"}

Это одна из самых старых моделей, подразумевающая **последовательное
прохождение стадий**, каждая из которых должна быть полностью завершена
до начала следующей.

В модели Waterfall легко управлять проектом благодаря её жёсткости, что
позволяет заранее определить стоимость и сроки разработки. Однако это
имеет и обратную сторону: каскадная модель даёт отличный результат
только в проектах с **чётко и заранее определёнными требованиями** и
способами их реализации.

Одним из ключевых недостатков является **отсутствие возможности сделать
шаг назад** без значительных издержек. Тестирование начинается только
после того, как разработка завершена или почти завершена. Продукты,
разработанные по данной модели без обоснованного её выбора, могут иметь
недочёты (список требований нельзя скорректировать в любой момент), о
которых становится известно лишь в конце из-за строгой
последовательности действий. Стоимость внесения изменений высока, так
как для их инициализации приходится ждать завершения всего проекта. Тем
не менее, фиксированная стоимость часто перевешивает минусы подхода.
Исправление осознанных в процессе создания недостатков возможно и, по
нашему опыту, требует от одного до трёх дополнительных соглашений к
контракту с небольшим ТЗ.

##### **«V-Model»**

![image.png](./media/image7.png){width="5.277777777777778in"
height="3.763888888888889in"}

V-образная модель унаследовала структуру \"шаг за шагом\" от каскадной
модели. Её особенность заключается в том, что она направлена на
тщательную проверку и **[тестирование
продукта](https://www.edsd.ru/ru/uslugi/testirovanie_po) уже на
первоначальных стадиях проектирования**. Стадия тестирования проводится
одновременно с соответствующей стадией разработки (например, во время
кодирования пишутся модульные тесты).

V-Model применима к системам, которым особенно важно **бесперебойное
функционирование**, например, прикладные программы в клиниках для
наблюдения за пациентами, интегрированное ПО для механизмов управления
аварийными подушками безопасности в транспортных средствах и так далее.

##### **Инкрементная модель «Incremental Model»**

Инкрементная модель --- это метод, в котором проект проектируется,
реализуется и тестируется **инкрементно** (то есть каждый раз с
небольшими добавлениями) до самого окончания разработки. Это включает
как разработку, так и дальнейшую поддержку продукта. Продукт считается
законченным, когда он удовлетворяет всем требованиям. Модель объединяет
элементы каскадной модели с прототипированием.

##### **Итеративная или итерационная модель (iteration - \"повторение\")**

Эта модель предполагает движение к выбранному финальному варианту
продукта через **повторяющиеся циклы разработки**. Такие циклы
называются итерациями. После каждого цикла создаётся новая версия
программного обеспечения. По мере продвижения по итерациям IT-продукт
становится всё более качественным и удобным.

![image.png](./media/image18.png){width="5.375in"
height="3.9444444444444446in"}

##### **Итеративно-инкрементная модель разработки**

В практике IT-компаний всё чаще используется **итеративно-инкрементная
модель**. Это гибрид, который объединяет в себе оба подхода. Например,
разработка инкрементов может происходить параллельно и циклами
(итеративно). Итеративно-инкрементная модель усиливает плюсы и
нивелирует минусы обеих моделей разработки.

##### **«Spiral Model» (спиральная модель)**

![image.png](./media/image3.png){width="5.388888888888889in"
height="3.361111111111111in"}

\"Спиральная модель\" похожа на инкрементную, но с **акцентом на анализ
рисков**. Она хорошо работает для решения критически важных
бизнес-задач, когда неудача несовместима с деятельностью компании, а
также в условиях выпуска новых продуктовых линеек, при необходимости
научных исследований и практической апробации.

Спиральная модель предполагает 4 этапа для каждого витка:

- планирование;

- анализ рисков;

- конструирование;

- оценка результата и при удовлетворительном качестве переход к новому
  витку.

##### **«Agile Model» (гибкая методология разработки)**

![image.png](./media/image16.png){width="5.361111111111111in"
height="3.3333333333333335in"}

В \"гибкой\" методологии разработки после каждой итерации **заказчик
может наблюдать результат** и понимать, удовлетворяет он его или нет.
Это одно из главных преимуществ гибкой модели. К её недостаткам относят
то, что из-за отсутствия конкретных формулировок результатов сложно
оценить трудозатраты и стоимость, требуемые на разработку. Экстремальное
программирование (XP) является одним из наиболее известных применений
гибкой модели на практике.

В основе такого типа --- непродолжительные ежедневные встречи ---
**\"Scrum\"** и регулярно повторяющиеся собрания (раз в неделю, раз в
две недели или раз в месяц), которые называются **\"Sprint\"**. На
ежедневных совещаниях участники команды обсуждают:

- отчёт о проделанной работе с момента последнего Scrum\'а;

- список задач, которые сотрудник должен выполнить до следующего
  собрания;

- затруднения, возникшие в ходе работы.

**«RAD Model» (rapid application development model или быстрая
разработка приложений)**

![image.png](./media/image19.png){width="5.541666666666667in"
height="3.4444444444444446in"}

RAD-модель --- это разновидность инкрементной модели. В RAD-модели
компоненты или функции разрабатываются несколькими
высококвалифицированными командами параллельно, подобно нескольким
мини-проектам. Временные рамки одного цикла жёстко ограничены. Созданные
модули затем интегрируются в один рабочий прототип. Синергия позволяет
очень быстро предоставить клиенту что-то рабочее для получения обратной
связи и внесения изменений.

# Жизненный цикл разработки ПО

### 

Этап 1: Сбор и анализ требований\
Этап 2: Планирование\
Этап 3: Проектирование и дизайн архитектуры\
Этап 4: Разработка продукта (написание кода)\
Этап 5: Тестирование\
Этап 6: Развертывание, эксплуатация и обслуживание продукта

![image.png](./media/image8.png){width="3.6527777777777777in"
height="3.6527777777777777in"}

# Жизненные циклы Тестирования и Бага

В Appfox мы придерживаемся систематических подходов к обеспечению
качества. Понимание жизненных циклов тестирования программного
обеспечения (STLC) и самого бага помогает нам эффективно управлять
процессами и поддерживать высокое качество продукта.

#### **Жизненный цикл тестирования ПО (STLC)**

**STLC (Software Testing Lifecycle)** --- это процесс тестирования,
который включает определённую последовательность шагов, чтобы
гарантировать достижение целей в области качества. В процессе STLC
каждое действие выполняется планомерно и систематически. Каждый этап
имеет разные цели и результаты.

- **Критерии входа (entry criteria):** Набор общих и специфичных условий
  для продолжения процесса с определённой задачей, например, для
  перехода к фазе тестирования. Цель критериев входа --- предотвращение
  начала задачи, которое может потребовать больше (бесполезных) усилий,
  чем устранение не пройденных критериев входа.

- **Критерии выхода (exit criteria):** Набор общих и специфичных
  условий, согласованных заранее с заинтересованными сторонами, для того
  чтобы процесс мог официально считаться завершённым. Цель критериев
  выхода --- предотвращение ситуации, когда задание считается
  завершённым, однако ещё существуют отдельные незавершённые части.
  Критерии выхода используются для отчётности, а также планирования
  того, когда остановить тестирование.

**Фазы STLC**

![image.png](./media/image12.png){width="4.902777777777778in"
height="3.3333333333333335in"}

1.  **Анализ требований (Requirement Analysis):** Один из важнейших
    этапов, поскольку именно на нём можно почти бесплатно исправить
    недостатки проекта. Этап анализа требований также определяет
    потенциальную потребность в автоматизированном тестировании и
    позволяет производить экономические расчёты затрат на рабочую силу
    на основе оценки проекта. На этом же этапе обсуждаются и
    документируются критерии начала и окончания тестирования.

2.  **Планирование тестирования (Test Planning):** На этом этапе
    формируется план тестирования. Определяются действия и ресурсы,
    которые помогут достичь целей тестирования (участники и их роли,
    инструменты, окружение). Во время планирования также определяются
    метрики, методы сбора и отслеживания этих метрик. Планы составляют
    исходя из требований, тестовой стратегии и анализа рисков.

3.  **Разработка тест-кейсов и чек-листов (Test Case Development):**
    Подразумевает использование ручного и автоматизированного
    тестирования для достижения полного охвата функциональности
    программного обеспечения. Процесс основан на заранее установленных
    требованиях. Чаще всего тест-кейсы для автоматического тестирования
    пишутся отдельно, так как кейсы для ручного тестирования описаны в
    чек-листах.

4.  **Настройка тестовой среды (Test Environment Setup):** В плане
    тестирования чётко указано, какую тестовую среду следует
    использовать. На этом этапе STLC настраиваются операционные системы
    и виртуальные машины, развёртываются инструменты тестирования, такие
    как Selenium, Katalon Studio, а также тестовая среда и базы данных
    проекта. Также направляются запросы к DevOps и администраторам, если
    требуется поддержка.

5.  **Выполнение тестов (Test Execution):** Тесты выполняются на основе
    готовой тестовой документации и правильно настроенной тестовой
    среды. Все результаты тестирования регистрируются в Системе
    управления тестированием. Отрицательно пройденные тесты, в которых
    фактический результат отличается от ожидаемого, регистрируются как
    ошибки и передаются команде разработчиков на доработку с последующей
    перепроверкой после исправления.

6.  **Завершение цикла испытаний (Test Cycle Closure):** На этом этапе
    происходит окончательная генерация отчётов о тестировании для
    клиента. Они должны включать затраченное время, процент обнаруженных
    ошибок и положительных результатов тестирования, общее количество
    обнаруженных и исправленных ошибок. Что касается отдела
    тестирования, это момент для анализа его работы, подведения итогов,
    анализа продуктивности и возможности внести предложения по улучшению
    качества тестирования.

#### **Жизненный цикл бага**

Баг проходит через несколько стандартных статусов, которые отражают его
текущее состояние от момента обнаружения до полного исправления или
отклонения.

##### **Стандартные статусы бага**

+-----------------------------------+------------------------------------------------------+
| Статус                            | Описание                                             |
+-----------------------------------+------------------------------------------------------+
| **Открыт (Open)**                 | Первый статус в цикле. Означает, что дефект          |
|                                   | обнаружен тестировщиком, зарегистрирован, и по нему  |
|                                   | создан баг-репорт, на основе которого разработчик    |
|                                   | будет искать и устранять дефект.                     |
+-----------------------------------+------------------------------------------------------+
| **В работе (In progress)**        | Статус означает, что дефект принят разработчиками и  |
|                                   | начат процесс его устранения. На этом этапе возможен |
|                                   | переход в статус **\"Отклонен\" (Declined)**.        |
+-----------------------------------+------------------------------------------------------+
| **Устранён (Fixed)**              | (Или Решён/Исправлен). Разработчики поработали с     |
|                                   | кодом, внесли нужные правки, пометили статусом       |
|                                   | «Исправлен» и возвращают тестировщикам для повторной |
|                                   | проверки.                                            |
+-----------------------------------+------------------------------------------------------+
| **Ожидает повторного тестирования | В статусе Retest дефект ожидает, когда тестировщики  |
| (Retest)**                        | повторно проверят его, убедившись, что всё в порядке |
|                                   | и код теперь исправлен.                              |
+-----------------------------------+------------------------------------------------------+
| **Повторно открыт (Reopen)**      | Если повторное тестирование не смогло устранить баг, |
|                                   | и он обнаруживается снова, ему присваивается статус  |
|                                   | Reopen. Баг открывается опять и ещё раз проходит по  |
|                                   | циклу.                                               |
+-----------------------------------+------------------------------------------------------+
| **Закрыт (Done)**                 | Дефект найден и устранён совместными усилиями        |
|                                   | разработчиков и тестировщиков, он больше не          |
|                                   | появляется, и ему можно присвоить статус Closed.     |
+-----------------------------------+------------------------------------------------------+
| **Отклонён (Declined)**           | Разработчик может отклонить баг, если тестировщик    |
|                                   | воспроизводит действия некорректно или не по         |
|                                   | требованиям.                                         |
+-----------------------------------+------------------------------------------------------+
| **Не баг (No bug)**               | Разработчик или ПМ может установить статус No bug,   |
|                                   | если это не является дефектом. После присваивается   |
|                                   | статус **\"Архив\" (Archive)**.                      |
+-----------------------------------+------------------------------------------------------+
| **Архив (Archive)**               | Статус устанавливается для всех элементов, которые   |
|                                   | не являются багами (не относится к багам со статусом |
|                                   | Done), например, для \"Не баг\".                     |
+-----------------------------------+------------------------------------------------------+
| **Другие возможные статусы**                                                             |
+-----------------------------------+------------------------------------------------------+
| Отложен (Deferred)                | Некоторые дефекты могут быть сочтены не очень        |
|                                   | важными, не приоритетными. Их можно отложить на      |
|                                   | потом и устранить в следующих релизах, присвоив      |
|                                   | статус Deferred и исключив из текущего цикла.        |
+-----------------------------------+------------------------------------------------------+
| Дубликат (Duplicate)              | Присваивается, если данный дефект уже                |
|                                   | зарегистрирован другим тестировщиком или суть        |
|                                   | дефекта та же.                                       |
+-----------------------------------+------------------------------------------------------+
| Не воспроизводится (Non           | Баг не удалось воспроизвести по какой-либо причине:  |
| Reproducible)                     | проблемы с платформой, окружением, тестовыми         |
|                                   | данными, порядком действий и т.п.                    |
+-----------------------------------+------------------------------------------------------+
| Невозможно устранить (Can't be    | Бывают ситуации, когда баг устранить невозможно по   |
| fixed)                            | какой-либо причине: недостатки технологии, высокая   |
|                                   | стоимость, нехватка времени, недостаточная           |
|                                   | квалификация или другие ограничения.                 |
+-----------------------------------+------------------------------------------------------+
| Требует уточнения (Need more      | По сути близок к статусу «Не воспроизводится», но с  |
| information)                      | нюансами. Такой статус присваивается, когда          |
|                                   | разработчики не сумели воспроизвести баг по шагам,   |
|                                   | предоставленным тестировщиком, или если тестировщик  |
|                                   | составил недостаточно подробный репорт.              |
+===================================+======================================================+

Отчёт о дефекте в конце его жизненного цикла (когда доказано, что дефект
исправлен) может закрыть тестировщик или
